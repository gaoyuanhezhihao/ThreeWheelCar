C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE FLASHTESTMAIN
OBJECT MODULE PLACED IN FlashTestMain.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE FlashTestMain.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //-----------------------------------------------------------------------------
   2          // F12x_UART0_Interrupt.c
   3          //-----------------------------------------------------------------------------
   4          // ????????????? RJ ?? ???????
   5          // ???????:     http://dadastudio.taobao.com/ 
   6          // ????????      C8051F12x-13x???.pdf ?? 21 ?:UART0
   7          //
   8          // Copyright 2006 Silicon Laboratories, Inc.
   9          // http://www.silabs.com
  10          //
  11          // Program Description:
  12          //
  13          // This program demonstrates how to configure the C8051F120 to write to and read 
  14          // from the UART interface. The program reads a word using the UART0 interrupts 
  15          // and outputs that word to the screen, with all characters in uppercase
  16          //
  17          // How To Test:
  18          //
  19          // 1) Download code to a 'F12x device that is connected to a UART transceiver
  20          // 2) Verify jumpers J6 and J9 are populated on the 'F12x TB.
  21          // 3) Connect serial cable from the transceiver to a PC
  22          // 4) On the PC, open HyperTerminal (or any other terminal program) and connect
  23          //    to the COM port at <BAUDRATE> and 8-N-1
  24          // 5) Download and execute code on an 'F12x target board.
  25          // 6) Type up to 64 characters into the Terminal and press Enter.  The MCU 
  26          //    will then print back the characters that were typed
  27          //   
  28          //
  29          // Target:         C8051F12x
  30          // Tool chain:     Keil C51 7.50 / Keil EVAL C51
  31          // Command Line:   None
  32          //
  33          // Release 1.0
  34          //    -Initial Revision (SM)
  35          //    -11 JULY 2007
  36          //
  37          //       P5.0-->PWMHigelevel bit0
  38          //       P5.1-->PWMHigelevel bit1
  39          //       P5.2-->PWMHigelevel bit2
  40          //       P5.3-->PWMHigelevel bit3
  41          //   P5.4-->PWMHigelevel bit4
  42          //       P5.5-->PWMHigelevel bit5
  43          //   P5.6-->PWMHigelevel bit6
  44          //       P5.7-->PWMHigelevel bit7
  45          //       P4.6-->PWMHigelevel bit8
  46          //       P4.7-->PWMHigelevel bit9
  47          //       P4.0-->cPWM1ChangeOrder
  48          //   P4.1-->cPWM2ChangeOrder
  49          
  50          //-----------------------------------------------------------------------------
  51          // Includes
  52          //-----------------------------------------------------------------------------
  53          
  54          #include <c8051f120.h>                 // SFR declarations
  55          #include <stdio.h>                     
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 2   

  56          #include <string.h>
  57          #include <F120_FlashPrimitives.h>
  58          #include <math.h>
  59          #include "MyDebug.h"
  60          //-----------------------------------------------------------------------------
  61          // 16-bit SFR Definitions for 'F12x
  62          //-----------------------------------------------------------------------------
  63          
  64          sfr16 RCAP2    = 0xca;                 // Timer2 capture/reload
  65          sfr16 TMR2     = 0xcc;                 // Timer2
  66          
  67          //-----------------------------------------------------------------------------
  68          // Global Constants
  69          //-----------------------------------------------------------------------------
  70          
  71          #define BAUDRATE     9600            // Baud rate of UART in bps
  72          #define UART1BAUDRATE 115200             
  73          #define Const_Control_Time      10                      //ADC cycle = Const_Control_Time*Timer0 cycle = 10*10ms=100ms
  74          sbit PWM1       =       P3^2;                      
  75          sbit IN11               =       P6^5;
  76          sbit IN12               =       P6^6;
  77          sbit TMR3Debug  =   P3^5;
  78          sbit SET                =       P3^1;
  79          sbit Key1               =       P7^2;
  80          sbit PWM3               =       P6^7;
  81          sbit IN31               =       P3^4;
  82          sbit IN32               =       P3^3;
  83          sbit DEBUGPORT  =   P3^0;
  84          sbit PWM1CHANGEORDER = P4^0;
  85          sbit PWM2CHANGEORDER = P4^1;
  86          sbit PWMDEGREE_HighBit0=P4^6;
  87          sbit PWMDEGREE_HighBit1=P4^7;
  88          sbit D0 = P5^0;
  89          sbit D1 = P5^1;
  90          sbit D2 = P5^2;
  91          sbit D3 = P5^3;
  92          sbit D4 = P5^4;
  93          sbit D5 = P5^5;
  94          sbit D6 = P5^6;
  95          sbit D7 = P5^7;
  96          // SYSTEMCLOCK = System clock frequency in Hz
  97          #define SYSTEMCLOCK       (22118400L * 9 / 4)
  98          #define TIMER0CLOCK                     (SYSTEMCLOCK/48)
  99          #define TIMER1CLOCK             (SYSTEMCLOCK/48)
 100          #define TIMER3CLOCK                     (SYSTEMCLOCK/48)
 101          #define MAP_ADC_ANGEL_SIZE  13
 102          #define UART_BUFFERSIZE 64
 103          #define UART1_BUFFERSIZE 22
 104          #define PWMDEGREE_Low8Bits P5
 105          
 106          //--------------------------------POSE & Control-------------------------------------------
 107          #define MAX_PWM 800
 108          #define ANGELRANGE_SIZE 7
 109          #define ANGELSCALE_10 0xF8E3  //-10
 110          #define ANGELSCALE_5 0xFC71  //-5
 111          #define ANGELSCALE_3 0xFDDD  //-3
 112          #define ANGELSCALE0  0x0000  //0
 113          #define ANGELSCALE3  0x0222  //3
 114          #define ANGELSCALE5  0x038E  //5
 115          #define ANGELSCALE10  0x071C  //10
 116          //-----------------------------------------------------------------------------
 117          // Function Prototypes
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 3   

 118          //-----------------------------------------------------------------------------
 119          
 120          void OSCILLATOR_Init (void);         
 121          void PORT_Init (void);
 122          void UART0_Init (void);
 123          void RerangeTheBufferQueue(unsigned char IndexOfBuffer);
 124          void WirelessModule_Init(void);
 125          void Uart0_SendByte(unsigned char value);
 126          void Uart0_TransmitString(unsigned char * pucString , int iStringSize );
 127          void TIMER0_Init(void);
 128          void TIMER1_Init(unsigned int count);
 129          void Calibration(void);
 130          void Delay_ms(unsigned int count);
 131          void Regulate(void);
 132          void FLASH_ByteWrite (FLADDR addr, char byte, bit SFLE);
 133          unsigned char FLASH_ByteRead (FLADDR addr, bit SFLE);
 134          void FLASH_PageErase (FLADDR addr, bit SFLE);
 135          void SaveMapToFlash(void);
 136          void RestoreMapFromFlash(void);
 137          void TIMER3_Init(void);
 138          void UART1_Init (void);
 139          void Uart1_SendByte(unsigned char value);
 140          void PWMChange(void);
 141          void TouchKeepAlive(void);
 142          void Acknowledge(unsigned char back);
 143          void LostConnect(void);
 144          void Check_Counter(unsigned int * Couter_L, unsigned int *Counter_R);
 145          //-----------------------------------------------------------------------------
 146          // Global Variables
 147          //-----------------------------------------------------------------------------
 148          
 149          //-------------------------------UART0-----------------------------------------
 150          unsigned int UART0_Receive_Buffer_Size = 0;
 151          unsigned char UART_Receive_Buffer_Queue[UART_BUFFERSIZE]={0};
 152          unsigned char * UART_Receive_Buffer_QueueHead=UART_Receive_Buffer_Queue;
 153          unsigned char * UART_Receive_Buffer_QueueBottom=UART_Receive_Buffer_Queue;
 154          unsigned char UART_Transmit_Buffer_Queue[UART_BUFFERSIZE];
 155          unsigned char * UART_Transmit_Buffer_QueueHead=UART_Transmit_Buffer_Queue;
 156          unsigned char * UART_Transmit_Buffer_QueueBottom=UART_Transmit_Buffer_Queue;
 157          unsigned char TX_Ready =1;
 158          static   char Byte;
 159                           char Rcv_New=0;
 160          //--------------------------------UART1-----------------------------------------
 161          unsigned char   Counter_UART1 = 0;
 162          unsigned char   Flag_NewFrame = 0;
 163          unsigned char   UART1_Receive_Buffer_Queue[UART1_BUFFERSIZE]={0};
 164          unsigned char * UART1_Receive_Buffer_QueueHead   = UART1_Receive_Buffer_Queue;
 165          unsigned char * UART1_Receive_Buffer_QueueBottom  = UART1_Receive_Buffer_Queue;
 166          
 167          
 168          //--------------------------------POSE & Control-------------------------------------------
 169          int a,angle,Temp,w;
 170          int ZeroPoint_a,ZeroPoint_w,ZeroPoint_angle,ZeroPoint_Temp;
 171          int iDeviation = 0;
 172          unsigned int uiAbsoluteDeviation =  0;
 173          unsigned int AbsoluteW_ui = 0;
 174          int iStablePoint = 0;
 175          bit RotateDirection = 0;
 176          
 177          int iAngleRange[] = 0;
 178          struct Pair_Angel_Control{
 179                  int Angel;
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 4   

 180                  int Kp;
 181                  int Ki;
 182                  int Kd;
 183          };
 184          struct Pair_Angel_Control Map_Angel_PID[ANGELRANGE_SIZE] = {{ANGELSCALE_10,5,0,1},\
 185                                                                                                                                          {ANGELSCALE_5,4,0,1},\
 186                                                                                                                                          {ANGELSCALE_3,3,0,1},\
 187                                                                                                                                          {ANGELSCALE0,1,0,1},\
 188                                                                                                                                          {ANGELSCALE3,2,0,1},\
 189                                                                                                                                          {ANGELSCALE5,3,0,1},\
 190                                                                                                                                          {ANGELSCALE10,5,0,1}};
 191          int iCurrentKey = 0;
 192          unsigned int KeepAliveTime_i=0;
 193                                                                                  
 194          //-------------------------------Motor--------------------------------
 195          unsigned int Motor1_Time=0;
 196          unsigned int Motor2_Time=0;
 197          
 198          unsigned int PWM1_HighLevelCount=0;
 199          unsigned int PWM1_LowLevelCount=0;
 200          float fPWM1_HighLevelPercent = 0.5f;
 201          bit pwm1_flag=0;
 202          
 203          unsigned int PWM3_HighLevelCount=0;
 204          unsigned int PWM3_LowLevelCount=0;
 205          float fPWM3_HighLevelPercent = 0.9f;
 206          bit pwm3_flag=0;
 207          
 208          unsigned char TH1_HighLevelPrefetch = 0;
 209          unsigned char TL1_HighLevelPrefetch = 0;
 210          unsigned char TMRH3_HighLevelPrefetch = 0;
 211          unsigned char TMRL3_HighLevelPrefetch = 0;
 212          
 213          unsigned char TH1_LowLevelPrefetch = 0;
 214          unsigned char TL1_LowLevelPrefetch = 0;
 215          unsigned char TMRH3_LowLevelPrefetch = 0;
 216          unsigned char TMRL3_LowLevelPrefetch = 0;
 217          
 218          unsigned int uiPWM1Degree=0;
 219          unsigned int uiPWM2Degree=0;
 220          bit     PWM1ChangeOrder = 0;
 221          bit     PWM2ChangeOrder = 0;
 222          
 223          char cOldRotateDirection = 0;
 224          //-------------------------------System--------------------------------
 225          char data Global_SFRPAGE_SAVE;
 226          //unsigned int i=0;
 227          char cDebugTmp=0;
 228          char Control_TimeIsUp = 0;
 229          unsigned char Control_Time=0;
 230          
 231          
 232          unsigned char TH0_Prefetch = 0;
 233          unsigned char TL0_Prefetch = 0;
 234          unsigned char PWM_debug1 = 0;
 235          unsigned char PWM_debug2 = 0;
 236          unsigned char PWM_debug3 = 0;
 237          unsigned char PWM_debug4 = 0;
 238          unsigned int TMR3_1000_circles = 0;
 239          unsigned int TMR4_1000_circles = 0;
 240          
 241          //-----------------------------------------------------------------------------
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 5   

 242          // main() Routine
 243          //-----------------------------------------------------------------------------
 244          
 245          void main (void)
 246          {
 247   1              unsigned int Counter_L =0;
 248   1              unsigned int *Counter_L_p = &Counter_L;
 249   1              unsigned int Counter_R = 0;
 250   1              unsigned int *Counter_R_p = &Counter_R;
 251   1              //Initialization
 252   1              SFRPAGE = CONFIG_PAGE;
 253   1              WDTCN = 0xDE;                       // Disable watchdog timer
 254   1              WDTCN = 0xAD;
 255   1              OSCILLATOR_Init();  
 256   1              PORT_Init();                       // Initialize crossbar and GPIO
 257   1              UART0_Init();                      // Initialize UART0
 258   1      //      UART1_Init();
 259   1              WirelessModule_Init();
 260   1              TIMER0_Init();
 261   1              TIMER4_Init();
*** WARNING C206 IN LINE 261 OF FlashTestMain.c: 'TIMER4_Init': missing function-prototype
 262   1              TIMER3_Init();
 263   1              EA = 1;
 264   1      
 265   1              //*************flash test**********************
 266   1      //      FLASH_PageErase(0x8000,1);
 267   1      //      for(i=0;i<MAP_ADC_ANGEL_SIZE;i++)
 268   1      //      {
 269   1      //              Map_ADC_Angel_array[i].ADC = i;
 270   1      //              Map_ADC_Angel_array[i].Angel = -i;
 271   1      //      }
 272   1      //      SaveMapToFlash();
 273   1      //      FLASH_PageErase(0x8000,1);
 274   1      //      FLASH_ByteWrite(0x8000,'j',1);
 275   1      //      FLASH_ByteWrite(0x8001,'a',1);
 276   1      //      cReadFlash = FLASH_ByteRead(0x8000,1);
 277   1      ////*******************PWM test******************
 278   1      //      uiPWM1Degree = 0;
 279   1      //      while(1)
 280   1      //      {
 281   1      //              uiPWM1Degree +=50;
 282   1      //              PWMChange(1);
 283   1      //              PWMChange(2);
 284   1      //      }
 285   1      ////-------------------PWM test------------------
 286   1              
 287   1              
 288   1      
 289   1      
 290   1              Uart0_TransmitString("Ready",strlen("Ready"));
 291   1              while (1)
 292   1              {
 293   2                      //if more than 20*50ms=1000ms is past since last message.
 294   2                      if(KeepAliveTime_i > 100)
 295   2                      {
 296   3                              LostConnect();
 297   3                      }
 298   2                      if(UART_Receive_Buffer_QueueHead < UART_Receive_Buffer_QueueBottom)
 299   2                      {
 300   3                              //Uart0_SendByte(*UART_Receive_Buffer_Queue);
 301   3                              //++UART_Receive_Buffer_Queue;
 302   3                              if( 0x53 == *UART_Receive_Buffer_QueueHead )
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 6   

 303   3                              {
 304   4                                      char WaitFailSign = 0;
 305   4                                      ++UART_Receive_Buffer_QueueHead;
 306   4                                      while( UART_Receive_Buffer_QueueBottom - UART_Receive_Buffer_QueueHead < 3 )
 307   4                                      {
 308   5                                              //wait the rest three char
 309   5                                              if(KeepAliveTime_i > 100)
 310   5                                              {
 311   6                                                      //wait too long 
 312   6                                                      WaitFailSign = 1;
 313   6                                                      break;
 314   6                                              }
 315   5                                      }
 316   4                                      if(WaitFailSign == 1) 
 317   4                                      {
 318   5                                              //wait too long. Abort this frame. 
 319   5                                              UART_Receive_Buffer_QueueHead = UART_Receive_Buffer_QueueHead;
 320   5                                              break;
 321   5                                      }
 322   4                                      
 323   4                                      //check the sum 
 324   4                                      if( *UART_Receive_Buffer_QueueHead + *(UART_Receive_Buffer_QueueHead+1) != *(UART_Receive_Buffer_Queue
             -Head+2) )
 325   4                                      {
 326   5                                              /*debug*/
 327   5                                              Uart0_SendByte('w');
 328   5                                              UART_Receive_Buffer_QueueHead+=3;
 329   5                                              /*debug end*/
 330   5                                              continue;
 331   5                                      }
 332   4                                      
 333   4                                      
 334   4                                      
 335   4                                      //next char (order) come
 336   4                                      switch(*UART_Receive_Buffer_QueueHead)
 337   4                                      {
 338   5                                              case 'g'://start the car
 339   5                                                      uiPWM1Degree=uiPWM2Degree=*(UART_Receive_Buffer_QueueHead+1);
 340   5                                                      PWMChange();
 341   5                                                      IN11=1;
 342   5                                                      IN12=0;
 343   5                                                      IN31=1;
 344   5                                                      IN32=0;
 345   5                                                      TouchKeepAlive();
 346   5                                                      Acknowledge(*UART_Receive_Buffer_QueueHead);
 347   5                                                      break;
 348   5                                              case 'f'://forward
 349   5                                                      uiPWM1Degree=uiPWM2Degree=*(UART_Receive_Buffer_QueueHead+1);
 350   5                                                      PWMChange();                                            
 351   5                                                      IN11=1;
 352   5                                                      IN12=0;
 353   5                                                      IN31=1;
 354   5                                                      IN32=0;
 355   5                                                      TouchKeepAlive();
 356   5                                                      Acknowledge(*UART_Receive_Buffer_QueueHead);
 357   5                                                      break;
 358   5                                              case 'l'://turn left
 359   5                                                      uiPWM1Degree=uiPWM2Degree=*(UART_Receive_Buffer_QueueHead+1);
 360   5                                                      PWMChange();                                            
 361   5                                                      IN11=0;
 362   5                                                      IN12=0;
 363   5                                                      IN31=1;
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 7   

 364   5                                                      IN32=0;
 365   5                                                      TouchKeepAlive();
 366   5                                                      Acknowledge(*UART_Receive_Buffer_QueueHead);
 367   5                                                      break;
 368   5                                              case 'r'://turn right
 369   5                                                      uiPWM1Degree=uiPWM2Degree=*(UART_Receive_Buffer_QueueHead+1);
 370   5                                                      PWMChange();                                            
 371   5      
 372   5                                                      IN11=1;
 373   5                                                      IN12=0;
 374   5                                                      IN31=0;
 375   5                                                      IN32=0;
 376   5                                                      TouchKeepAlive();
 377   5                                                      Acknowledge(*UART_Receive_Buffer_QueueHead);
 378   5                                                      break;
 379   5                                              case 'b'://go back
 380   5                                                      uiPWM1Degree=uiPWM2Degree=*(UART_Receive_Buffer_QueueHead+1);
 381   5                                                      PWMChange();
 382   5                                                      IN11=0;
 383   5                                                      IN12=1;
 384   5                                                      IN31=0;
 385   5                                                      IN32=1;
 386   5                                                      TouchKeepAlive();
 387   5                                                      Acknowledge(*UART_Receive_Buffer_QueueHead);
 388   5                                                      break;
 389   5                                              case 's'://stop
 390   5                                                      uiPWM1Degree=uiPWM2Degree=0;
 391   5                                                      PWMChange();
 392   5                                                      IN11=0;
 393   5                                                      IN12=0;
 394   5                                                      IN31=0;
 395   5                                                      IN32=0;
 396   5                                                      TouchKeepAlive();
 397   5                                                      Acknowledge(*UART_Receive_Buffer_QueueHead);
 398   5                                                      break;
 399   5                                              default:
 400   5                                                      /*debug*/
 401   5                                                      Acknowledge('n');//No such order
 402   5                                                      /*debug end*/
 403   5                                                      break;                                          
 404   5                                      }
 405   4                                      UART_Receive_Buffer_QueueHead+=3;
 406   4                              }
 407   3                              else
 408   3                              {
 409   4                                      ++UART_Receive_Buffer_QueueHead;
 410   4                              }
 411   3                              
 412   3                      }       
 413   2                      // Get the counter information
 414   2                      Check_Counter(Counter_L_p, Counter_R_p);
 415   2              }
 416   1      }
 417          
 418          //-----------------------------------------------------------------------------
 419          // Initialization Subroutines
 420          //-----------------------------------------------------------------------------
 421          
 422          //-----------------------------------------------------------------------------
 423          // OSCILLATOR_Init
 424          //-----------------------------------------------------------------------------
 425          //
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 8   

 426          // Return Value : None
 427          // Parameters   : None
 428          //
 429          // This function initializes the system clock to use the PLL as its clock
 430          // source, where the PLL multiplies the external 22.1184MHz crystal by 9/4.
 431          //
 432          //-----------------------------------------------------------------------------
 433          void OSCILLATOR_Init (void)
 434          {
 435   1         int i=0;                              // Software timer
 436   1      
 437   1         char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 438   1      
 439   1         SFRPAGE = CONFIG_PAGE;              // Set SFR page
 440   1      
 441   1         OSCICN = 0x80;                      // Set internal oscillator to run
 442   1                                             // at its slowest frequency
 443   1      
 444   1         CLKSEL = 0x00;                      // Select the internal osc. as
 445   1                                             // the SYSTEMCLOCK source
 446   1      
 447   1         // Initialize external crystal oscillator to use 22.1184 MHz crystal
 448   1      
 449   1         OSCXCN = 0x67;                      // Enable external crystal osc.
 450   1          for(i=0; i < 256; ) // Wait at least 1ms
 451   1              {
 452   2                      i++;
 453   2              }
 454   1         while (!(OSCXCN & 0x80));           // Wait for crystal osc to settle
 455   1      
 456   1         SFRPAGE = LEGACY_PAGE;
 457   1         FLSCL |=  0x30;                     // Initially set FLASH read timing for
 458   1                                             // 100MHz SYSTEMCLOCK (most conservative
 459   1                                             // setting)
 460   1         if (SYSTEMCLOCK <= 25000000L) {           
 461   2         // Set FLASH read timing for <=25MHz
 462   2            FLSCL &= ~0x30;
 463   2         } else if (SYSTEMCLOCK <= 50000000L) {    
 464   2         // Set FLASH read timing for <=50MHz
 465   2            FLSCL &= ~0x20;
 466   2         } else if (SYSTEMCLOCK <= 75000000L) {    
 467   2         // Set FLASH read timing for <=75MHz
 468   2            FLSCL &= ~0x10;
 469   2         } else {                            // set FLASH read timing for <=100MHz
 470   2            FLSCL &= ~0x00;
 471   2         }
 472   1      
 473   1         // Start PLL for 50MHz operation
 474   1         SFRPAGE = PLL0_PAGE;
 475   1         PLL0CN = 0x04;                      // Select EXTOSC as clk source
 476   1         PLL0CN |= 0x01;                     // Enable PLL power
 477   1         PLL0DIV = 0x04;                     // Divide by 4
 478   1         PLL0FLT &= ~0x0f;
 479   1         PLL0FLT |=  0x0f;                   // Set Loop Filt for (22/4)MHz input clock
 480   1         PLL0FLT &= ~0x30;                   // Set ICO for 30-60MHz
 481   1         PLL0FLT |=  0x10;
 482   1      
 483   1         PLL0MUL = 0x09;                     // Multiply by 9
 484   1      
 485   1         // wait at least 5us
 486   1         for (i = 0; i < 256; )
 487   1         {
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 9   

 488   2                 i++;
 489   2         }
 490   1      
 491   1         PLL0CN |= 0x02;                     // Enable PLL
 492   1      
 493   1         while (PLL0CN & 0x10 == 0x00);      // Wait for PLL to lock
 494   1      
 495   1         SFRPAGE = CONFIG_PAGE;
 496   1      
 497   1         CLKSEL = 0x02;                      // Select PLL as SYSTEMCLOCK source
 498   1      
 499   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFRPAGE
 500   1      }
 501          
 502          //-----------------------------------------------------------------------------
 503          // PORT_Init
 504          //-----------------------------------------------------------------------------
 505          //
 506          // Return Value : None
 507          // Parameters   : None
 508          //
 509          // This function configures the crossbar and GPIO ports.
 510          //
 511          // P0.0   digital   push-pull     UART TX
 512          // P0.1   digital   open-drain    UART RX
 513          //-----------------------------------------------------------------------------
 514          void PORT_Init (void)
 515          {
 516   1              char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 517   1      
 518   1              SFRPAGE = CONFIG_PAGE;              // Set SFR page
 519   1      
 520   1              XBR0     = 0x04;                    // Enable UART0
 521   1      //      XBR0    |= 0x08;                     // Route CEX0 to P0.2
 522   1              
 523   1              XBR1     = 0x20;                                        //Enable T2
 524   1              XBR2     = 0x40;                    // Enable crossbar and weak pull-up
 525   1              XBR2    |= 0X08;                                        //Enable T4
 526   1              XBR2    |= 0x04;                                        //Enable UART1
 527   1       //   P1MDIN   = 0xFF;                                   
 528   1              P0MDOUT |= 0x04;                    // Set CEX0 (P0.2) to push-pull
 529   1              P0MDOUT |= 0x01;                    // Set TX pin to push-pull
 530   1              P0MDOUT |= 0x04;                                        //Set UART1 TX pin to push-pull
 531   1      
 532   1              P3MDOUT = 0x18;                                         // P3.3 P3.4 is  push-pull
 533   1      //      P6MDOUT = 0x60;                                         // P6.x is push-pull
 534   1              P6              &= ~0x80;
 535   1              P6MDOUT = 0xFF;
 536   1              P5MDOUT = 0xFF;                                         //P6 is push-pull
 537   1              P4MDOUT = 0xC3;                                         //P4.7,4.6,4.0,4.1 is push-pull
 538   1      //      P7MDOUT = 0x00;                                         //P7.x is  open-drain
 539   1              SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 540   1      }
 541          
 542          //-----------------------------------------------------------------------------
 543          // TIMER0_Init
 544          //-----------------------------------------------------------------------------
 545          //
 546          //
 547          //-----------------------------------------------------------------------------
 548          void TIMER0_Init(void)
 549          {
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 10  

 550   1      
 551   1              char data SFRPAGE_SAVE =SFRPAGE;
 552   1              SFRPAGE=TIMER01_PAGE;
 553   1              TCON &= ~0x30;//stop the timer0
 554   1              TMOD &= ~0x00;//Set the timer0 work in mode of hex
 555   1              TMOD |= 0x01;
 556   1              CKCON &= 0xf0;
 557   1              CKCON |= 0x02;
 558   1              CKCON &= ~0x08;//Timer 0 uses the clock defined by the prescale bits
 559   1              TR0 = 0;
 560   1              TH0= (0xFFFF-TIMER0CLOCK/20)>>8; //Timer0 cycle = 50ms
 561   1              TL0=  0xFFFF-TIMER0CLOCK/20;
 562   1              ET0 = 1;//Enable interrupt
 563   1              TR0 = 1;//Run Timer0
 564   1              SFRPAGE = SFRPAGE_SAVE;
 565   1      }
 566          
 567          //-----------------------------------------------------------------------------
 568          // TIMER1_Init
 569          //-----------------------------------------------------------------------------
 570          //
 571          // Return Value : None
 572          // Parameters   :
 573          //   1)  int counts - calculated Timer overflow rate
 574          //                    range is postive range of integer: 0 to 32767
 575          //
 576          // Configure Timer1 to auto-reload at interval specified by <counts> (no
 577          // interrupt generated) using SYSCLK as its time base.
 578          //
 579          //-----------------------------------------------------------------------------
 580          //void TIMER1_Init(unsigned int count)
 581          //{
 582          //      char data SFRPAGE_SAVE =SFRPAGE;
 583          //      PWM1_HighLevelCount = count * fPWM1_HighLevelPercent;
 584          //      PWM1_LowLevelCount = (float)count * (1-fPWM1_HighLevelPercent);
 585          //      SFRPAGE=TIMER01_PAGE;
 586          //      TCON &= ~0xC0;//stop the timer1
 587          //      TMOD &= ~0x00;//Set the timer1 work in mode of hex
 588          //      TMOD |= 0x10;
 589          //      
 590          //      CKCON &=0x0f;//clear CKCON bit4~7
 591          //      CKCON |= 0x10;//Timer 1 use SYSTEMCLOCK
 592          //      
 593          //      TH1_HighLevelPrefetch = ( 0xffff - (unsigned int) (count * fPWM1_HighLevelPercent) )>>8;
 594          //      TL1_HighLevelPrefetch =   0xffff - (unsigned int) (count * fPWM1_HighLevelPercent) ;
 595          //      TH1_LowLevelPrefetch = (  0xffff - (unsigned int )( count * (1-fPWM1_HighLevelPercent) )  )>>8;
 596          //      TL1_LowLevelPrefetch =    0xffff - (unsigned int) (count * (1-fPWM1_HighLevelPercent));
 597          //      ET1 = 1;//Enable interrupt;
 598          //      TCON |= 0xC0;//start the timer1
 599          //      
 600          //      SFRPAGE = SFRPAGE_SAVE;
 601          //}
 602          
 603          //-----------------------------------------------------------------------------
 604          // TIMER3_Init
 605          //-----------------------------------------------------------------------------
 606          void Timer3_Init(void)
 607          {
 608   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 609   1      
 610   1              SFRPAGE = TMR3_PAGE;                // Set SFR page
 611   1              TMR3CF  = 0x00;
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 11  

 612   1              TMR3CN  = 0x00;
 613   1              TMR3CN  = 0x02;
 614   1      //      tmp=TMR3CN;
 615   1      //      TMR3CF &= ~0x18;                    // Timer3 uses SYSCLK/12
 616   1              TMR3L = 0x00;                       // Init the Timer3 register
 617   1              TMR3H = 0x00;
 618   1              TMR3CN |= 0x04;                      // Enable Timer3 in auto-reload mode
 619   1      //      ET4 = 1;                            // Timer4 interrupt enabled
 620   1              TR3 = 1;
 621   1              
 622   1              SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 623   1      }
 624          void Timer4_Init(void)
 625          {
 626   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 627   1      
 628   1              SFRPAGE = TMR4_PAGE;                // Set SFR page
 629   1              TMR4CF  = 0x00;
 630   1              TMR4CN  = 0x00;
 631   1              TMR4CN  = 0x02;
 632   1      //      tmp=TMR4CN;
 633   1              TMR4L = 0x00;                       // Init the Timer3 register
 634   1              TMR4H = 0x00;
 635   1              TMR4CN |= 0x04;                      // Enable Timer3 in auto-reload mode
 636   1      //      ET4 = 1;                            // Timer4 interrupt enabled
 637   1              TR4 = 1;
 638   1              
 639   1              SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 640   1      }
 641          void Timer3_ISR(void) interrupt 14
 642          {
 643   1              char data SFRPAGE_SAVE =SFRPAGE;//Save current SFP page
 644   1              SFRPAGE = TMR3_PAGE;
 645   1              TMR3Debug = ~TMR3Debug;
 646   1      
 647   1              
 648   1              if( Control_Time == 0 )
 649   1              {
 650   2                      Control_Time = Const_Control_Time;
 651   2                      Control_TimeIsUp=1;
 652   2      //              /***************Debug Begin***********************/
 653   2      //              IN31 ^= 1;
 654   2      //              //---------------Debug End ---------------------------
 655   2              }
 656   1              else
 657   1              {
 658   2                      Control_Time--;
 659   2              }
 660   1              TMR3CN &= ~0x80;//clear interrupt flag
 661   1              SFRPAGE=Global_SFRPAGE_SAVE;
 662   1              SFRPAGE = SFRPAGE_SAVE;
 663   1      }
 664          
 665          //-----------------------------------------------------------------------------
 666          // UART0_Init   Variable baud rate, Timer 2, 8-N-1
 667          //-----------------------------------------------------------------------------
 668          //
 669          // Return Value : None
 670          // Parameters   : None
 671          //
 672          // Configure UART0 for operation at <baudrate> 8-N-1 using Timer2 as
 673          // baud rate source.
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 12  

 674          //
 675          //-----------------------------------------------------------------------------
 676          void UART0_Init (void)
 677          {
 678   1         char SFRPAGE_SAVE;
 679   1      
 680   1         SFRPAGE_SAVE = SFRPAGE;             // Preserve SFRPAGE
 681   1      
 682   1         SFRPAGE = TMR2_PAGE;
 683   1      
 684   1         TMR2CN = 0x00;                      // Timer in 16-bit auto-reload up timer
 685   1                                             // mode
 686   1         TMR2CF = 0x08;                      // SYSCLK is time base; no output;
 687   1                                             // up count only
 688   1         RCAP2 = - ((long) SYSTEMCLOCK/BAUDRATE/16);
 689   1         TMR2 = RCAP2;
 690   1         TR2= 1;                             // Start Timer2
 691   1      
 692   1         SFRPAGE = UART0_PAGE;
 693   1      
 694   1         SCON0 = 0x50;                       // 8-bit variable baud rate;
 695   1                                             // 9th bit ignored; RX enabled
 696   1                                             // clear all flags
 697   1         SSTA0 = 0x15;                       // Clear all flags; enable baud rate
 698   1                                             // doubler (not relevant for these
 699   1                                             // timers);
 700   1                                             // Use Timer2 as RX and TX baud rate
 701   1                                             // source;
 702   1         ES0 = 1;  
 703   1         IP |= 0x10;
 704   1      
 705   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFRPAGE
 706   1      }
 707          
 708          
 709          //-----------------------------------------------------------------------------
 710          // Interrupt Service Routines
 711          //-----------------------------------------------------------------------------
 712          
 713          //-----------------------------------------------------------------------------
 714          // Timer0_ISR
 715          //-----------------------------------------------------------------------------
 716          //
 717          //
 718          //-----------------------------------------------------------------------------
 719          void Timer0_ISR(void) interrupt 1
 720          {       
 721   1              Global_SFRPAGE_SAVE=SFRPAGE;//Save current SFP page
 722   1              SFRPAGE=CONFIG_PAGE;
 723   1              KeepAliveTime_i++;
 724   1              
 725   1              TF0=0;
 726   1              SFRPAGE=Global_SFRPAGE_SAVE;
 727   1      }
 728          //-----------------------------------------------------------------------------
 729          // Timer1_ISR
 730          //-----------------------------------------------------------------------------
 731          //
 732          //
 733          //-----------------------------------------------------------------------------
 734          //void Timer1_ISR(void) interrupt 3
 735          //{
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 13  

 736          //      char data SFRPAGE_SAVE =SFRPAGE;//Save current SFP page
 737          //      if(!pwm1_flag)
 738          //      {
 739          //                      
 740          //              //Start of High level
 741          //                      pwm1_flag = 1;  //Set flag
 742          //                      SFRPAGE=CONFIG_PAGE;
 743          //                      PWM1 = 1;       //Set PWM o/p pin
 744          //                      
 745          //                      TH1 = TH1_HighLevelPrefetch;    //Load timer
 746          //                      TL1 = TL1_HighLevelPrefetch;
 747          //                      TF0 = 0;                //Clear interrupt flag
 748          //                      SFRPAGE=SFRPAGE_SAVE;
 749          //                      return;         //Return
 750          //      }
 751          //      else
 752          //      {       //Start of Low level
 753          //              pwm1_flag = 0;  //Clear flag
 754          //              SFRPAGE=CONFIG_PAGE;
 755          //              PWM1 = 0;       //Clear PWM o/p pin
 756          //              
 757          //              TH1 = TH1_LowLevelPrefetch;     //Load timer
 758          //              TL1 = TL1_LowLevelPrefetch;
 759          //              TF0 = 0;        //Clear Interrupt flag
 760          //              
 761          //              SFRPAGE=SFRPAGE_SAVE;
 762          //              return;         //return
 763          //      }
 764          //}
 765          
 766          //void Timer3_ISR(void) interrupt 14
 767          //{
 768          //      char data SFRPAGE_SAVE =SFRPAGE;//Save current SFP page
 769          //      if(!pwm3_flag)
 770          //      {
 771          //                      
 772          //              //Start of High level
 773          //                      pwm3_flag = 1;  //Set flag
 774          //                      SFRPAGE = CONFIG_PAGE;
 775          //                      PWM3 = 1;       //Set PWM o/p pin
 776          //              
 777          //                      SFRPAGE = TMR3_PAGE;
 778          //                      TMR3H = TMRH3_HighLevelPrefetch;        //Load timer
 779          //                      TMR3L = TMRL3_HighLevelPrefetch;
 780          //                                              
 781          //                      TF3 = 0;                //Clear interrupt flag
 782          //              
 783          //                      SFRPAGE = SFRPAGE_SAVE;
 784          //                      return;
 785          //      }
 786          //      else
 787          //      {       //Start of Low level
 788          //              pwm3_flag = 0;  //Clear flag
 789          //              
 790          //              SFRPAGE = CONFIG_PAGE;
 791          //              PWM3 = 0;       //Set PWM o/p pin
 792          //              
 793          //              SFRPAGE = TMR3_PAGE;
 794          //              TMR3H = TMRH3_LowLevelPrefetch; //Load timer
 795          //              TMR3L = TMRL3_LowLevelPrefetch;
 796          //              
 797          //              
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 14  

 798          //              TF3 = 0;        //Clear Interrupt flag
 799          //              
 800          //              SFRPAGE = SFRPAGE_SAVE;
 801          //              return; 
 802          //      }
 803          //}
 804          //-----------------------------------------------------------------------------
 805          // UART0_Interrupt
 806          //-----------------------------------------------------------------------------
 807          //
 808          // This routine is invoked whenever a character is entered or displayed on the
 809          // Hyperterminal.
 810          //
 811          //-----------------------------------------------------------------------------
 812          
 813          void UART0_Interrupt (void) interrupt 4
 814          {
 815   1         SFRPAGE = UART0_PAGE;
 816   1      
 817   1         if ( RI0 == 1 ) //if the buffer is not full
 818   1         {
 819   2            
 820   2                      Byte = SBUF0;                      // Read a character from UART
 821   2                      //if the buffer is't full
 822   2                  if(  (UART_Receive_Buffer_QueueBottom-UART_Receive_Buffer_QueueHead) < UART_BUFFERSIZE )
 823   2                  {
 824   3                          if ( UART_Receive_Buffer_QueueBottom < (UART_Receive_Buffer_Queue+UART_BUFFERSIZE) )
 825   3                              {
 826   4                                      *UART_Receive_Buffer_QueueBottom = Byte; // Store in array
 827   4                                      UART_Receive_Buffer_QueueBottom++;
 828   4                                      if( UART_Receive_Buffer_QueueBottom >= (UART_Receive_Buffer_Queue+UART_BUFFERSIZE) )
 829   4                                              RerangeTheBufferQueue('r');
 830   4                                      Rcv_New=1;//Notice new message come
 831   4                                      UART0_Receive_Buffer_Size++;
 832   4                              }
 833   3                              else
 834   3                                      RerangeTheBufferQueue('r');
 835   3                  }
 836   2                  RI0 = 0;                           // Clear interrupt flag
 837   2         }
 838   1      
 839   1         if (TI0 == 1)                   // Check if transmit flag is set
 840   1         {
 841   2                 TX_Ready = 1;
 842   2                 TI0 = 0;
 843   2      //      if ( UART_Transmit_Buffer_QueueHead < UART_Transmit_Buffer_QueueBottom )         // If buffer not 
             -empty
 844   2      //      {
 845   2      ////         Byte = UART_Buffer[UART_Output_First];
 846   2      ////         if ((Byte >= 0x61) && (Byte <= 0x7A)) { // If upper case letter
 847   2      ////            Byte -= 32; }
 848   2      ////                                    int count = UART_Transmit_Buffer_QueueBottom - UART_Transmit_Buffer_QueueHead;
 849   2      ////                                    for(;count>0;count--)
 850   2      ////                                    {
 851   2      ////                                            Uart0_SendByte(*UART_Transmit_Buffer_QueueHead);  // Transmit to Hyperterminal
 852   2      ////                                        UART_Transmit_Buffer_QueueHead++;
 853   2      ////                                    }
 854   2      ////              while( UART_Transmit_Buffer_QueueHead < UART_Transmit_Buffer_QueueBottom )
 855   2      ////              {
 856   2      //                        TI0 = 0;
 857   2      //                        SBUF0 = *UART_Transmit_Buffer_QueueHead;
 858   2      //                        while( !TI0 );
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 15  

 859   2      //                        ++UART_Transmit_Buffer_QueueHead;
 860   2      ////              }
 861   2      //      }
 862   2      //      else
 863   2      //        {
 864   2      //                TX_Ready = 1;                    // Indicate transmission complete
 865   2      //                TI0 = 0;                           // Clear interrupt flag
 866   2      //        }
 867   2         }
 868   1      }
 869          //-----------------------------------------------------------------------------
 870          // UART1_Interrupt
 871          //-----------------------------------------------------------------------------
 872          //
 873          // This routine is invoked whenever a character is entered or displayed on the
 874          // Hyperterminal.
 875          //
 876          //-----------------------------------------------------------------------------
 877          
 878          
 879          
 880          //-----------------------------------------------------------------------------
 881          // RerangeTheBufferQueue
 882          //-----------------------------------------------------------------------------
 883          //
 884          // This routine is invoked to rerange the UART buffer queue when the bottom point has get to the bottom li
             -mit
 885          //-----------------------------------------------------------------------------
 886          void RerangeTheBufferQueue( char IndexOfBuffer)
 887          {
 888   1              if( IndexOfBuffer == 'r')//rerange the receive buffer
 889   1              {
 890   2                      int count = UART_Receive_Buffer_QueueBottom-UART_Receive_Buffer_QueueHead;
 891   2                      int i=0;
 892   2                      for(i=0;i<count;i++)
 893   2                      {
 894   3                                      *(UART_Receive_Buffer_Queue+i)= UART_Receive_Buffer_QueueHead;
*** WARNING C260 IN LINE 894 OF FlashTestMain.c: '=': pointer truncation
 895   3                                      UART_Receive_Buffer_QueueHead++;
 896   3                                      
 897   3                      }
 898   2                      UART_Receive_Buffer_QueueHead=UART_Receive_Buffer_Queue;
 899   2                      UART_Receive_Buffer_QueueBottom=UART_Receive_Buffer_QueueHead+count;
 900   2              }
 901   1              
 902   1              if( IndexOfBuffer == 't')//rerange the transmit buffer
 903   1              {
 904   2                      int count = UART_Transmit_Buffer_QueueBottom-UART_Transmit_Buffer_QueueHead;
 905   2                      int i=0;  
 906   2                      for(i=0;i<count;i++)
 907   2                      {
 908   3                                      *(UART_Transmit_Buffer_Queue+i)= UART_Transmit_Buffer_QueueHead;
*** WARNING C260 IN LINE 908 OF FlashTestMain.c: '=': pointer truncation
 909   3                                      UART_Transmit_Buffer_QueueHead++;
 910   3                                      
 911   3                      }
 912   2                      UART_Transmit_Buffer_QueueHead=UART_Transmit_Buffer_Queue;
 913   2                      UART_Transmit_Buffer_QueueBottom=UART_Transmit_Buffer_QueueHead+count;
 914   2              }       
 915   1      }
 916          //-----------------------------------------------------------------------------
 917          // WirelessModule_Init
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 16  

 918          //-----------------------------------------------------------------------------
 919          //
 920          //-----------------------------------------------------------------------------
 921          void WirelessModule_Init(void)
 922          {
 923   1              SET=1; // Enter the SET mode of the wireless module
 924   1              memset( UART_Transmit_Buffer_Queue,0,sizeof(UART_Transmit_Buffer_Queue) );
 925   1      }
 926          //-----------------------------------------------------------------------------
 927          // Uart0_SendByte
 928          //-----------------------------------------------------------------------------
 929          //
 930          //-----------------------------------------------------------------------------
 931          void Uart0_SendByte(unsigned char value)
 932          {
 933   1              char data SFRPAGE_SAVE = SFRPAGE;//save current SFR page
 934   1              int i = 0;
 935   1              SFRPAGE = UART0_PAGE;
 936   1      //      //Check if the uart transmit is ready
 937   1      //      while(1)
 938   1      //      {
 939   1      //              if( TI0 == 0 && TX_Ready == 1)
 940   1      //              {
 941   1      //                      break;
 942   1      //              }
 943   1      //      }
 944   1      //      
 945   1      //      //Check if there are enough space
 946   1      //      if( UART_Transmit_Buffer_QueueBottom - UART_Transmit_Buffer_Queue >= UART_BUFFERSIZE )
 947   1      //      {
 948   1      //              RerangeTheBufferQueue('t');
 949   1      //      }
 950   1      //      //Write the Byte to the Transmit queue
 951   1      //      *UART_Transmit_Buffer_QueueBottom = value;
 952   1      //      ++UART_Transmit_Buffer_QueueBottom;
 953   1      //      //Set the TI0 
 954   1      //      TI0 = 1;
 955   1          while( TX_Ready == 0 );
 956   1              
 957   1              TI0 = 0;
 958   1              TX_Ready = 0;
 959   1              SBUF0 = value;
 960   1              while(!TX_Ready)
 961   1              {
 962   2                      ;
 963   2              }
 964   1              SFRPAGE = SFRPAGE_SAVE;//Recover the SFR Page
 965   1      }
 966          //-----------------------------------------------------------------------------
 967          // Calibration
 968          //-----------------------------------------------------------------------------
 969          //
 970          //-----------------------------------------------------------------------------
 971          //void Calibration(void)
 972          //{
 973          //      char a_flag = 0,w_flag = 0,angle_flag = 0;
 974          //      UART0_Receive_Buffer_Size = UART_Receive_Buffer_QueueBottom - UART_Receive_Buffer_QueueHead;
 975          ////    strcat(UART_Transmit_Buffer_QueueHead,"ReadyToAdjust");
 976          ////    UART_Transmit_Buffer_QueueBottom += strlen("ReadyToAdjust");
 977          //      Uart0_SendByte('R');
 978          //      
 979          ////    Global_SFRPAGE_SAVE = SFRPAGE;
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 17  

 980          ////    SFRPAGE = ADC0_PAGE;
 981          ////    TX_Ready = 0;                  // Set the flag to zero
 982          ////    TI0 = 1;                       // Set transmit flag to 1
 983          ////    SFRPAGE = Global_SFRPAGE_SAVE;
 984          //      
 985          //      while(1)
 986          //      {
 987          //              while( Rcv_New == 0 );//Wait for new message
 988          //              Rcv_New = 0;
 989          //              
 990          //              if( *UART_Receive_Buffer_QueueHead++ != 'Z' )
 991          //              {
 992          //                      continue;
 993          //              }
 994          //              else
 995          //              {
 996          //                      while(1)
 997          //                      {
 998          //                              if(UART1_Receive_Buffer_Queue[0]==0x55)      
 999          //                              {  
1000          //                                      switch(UART1_Receive_Buffer_Queue [1])
1001          //                                      {
1002          //                                              case 0x51:
1003          //                                              a = (int)(UART1_Receive_Buffer_Queue [3]<<8| UART1_Receive_Buffer_Queue [2]);
1004          //                                              Temp = (int)(UART1_Receive_Buffer_Queue [9]<<8| UART1_Receive_Buffer_Queue [8]);
1005          //                                              a_flag = 1;
1006          //                                              break;
1007          //                                              case 0x52:
1008          //                                              w = (int)(UART1_Receive_Buffer_Queue [3]<<8| UART1_Receive_Buffer_Queue [2]);
1009          //                                              w_flag = 1;
1010          //                                              break;
1011          //                                              case 0x53:
1012          //                                              angle = (int)((unsigned int)UART1_Receive_Buffer_Queue [3]<<8| UART1_Receive_Buffer_Queue [2]);
1013          //                                              angle_flag = 1;
1014          //                                              break;
1015          //                                      } 
1016          //                              }
1017          //                              
1018          //                              if( a_flag + w_flag + angle_flag == 3 )
1019          //                              {
1020          //                                      break;
1021          //                              }
1022          //                      }
1023          //                      
1024          //                      //Save the current state to ZeroPoint
1025          //                      ZeroPoint_a = a;
1026          //                      ZeroPoint_w = w;
1027          //                      ZeroPoint_angle = angle;
1028          //                      ZeroPoint_Temp = Temp;
1029          //                      //
1030          //                      SaveMapToFlash();
1031          //                      return;
1032          //              }
1033          
1034          //      }
1035          //}
1036          
1037          
1038          //-----------------------------------------------------------------------------
1039          //      Delay_ms
1040          //-----------------------------------------------------------------------------
1041          //      input:count
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 18  

1042          //      output:void
1043          //      make the Program wait for count ms
1044          //-----------------------------------------------------------------------------
1045          void Delay_ms(unsigned int count)
1046          {
1047   1              unsigned char ii,jj;
1048   1              for(ii=0;ii<count;ii++)
1049   1              {
1050   2                      for(jj=0;jj<250;jj++)
1051   2                              ;
1052   2              }
1053   1      }
1054          
1055          
1056          
1057          
1058          
1059          void Uart0_TransmitString(unsigned char * pucString , int iStringSize )
1060          {
1061   1              unsigned char *pucHeadofString = pucString;
1062   1      //      if( strlen(pucString) != iStringSize )
1063   1      //      {
1064   1      //              ERROR("Uart0_TransmitString():string lenth not match");
1065   1      //      }
1066   1              
1067   1      
1068   1              while( *pucHeadofString != 0 )
1069   1              {
1070   2                      Uart0_SendByte(*pucHeadofString);
1071   2                      ++pucHeadofString;
1072   2              }
1073   1              
1074   1              
1075   1      }
*** WARNING C280 IN LINE 1059 OF FlashTestMain.c: 'iStringSize': unreferenced local variable
1076          
1077          void PWMChange(void)
1078          {
1079   1              int i= 0;
1080   1              /*************************DEBUG BEGIN*************************/
1081   1              if( uiPWM1Degree > 800 )
1082   1              {
1083   2                      ERROR("void PWMChange(char PWMChannel):PWMDegree is too large");
1084   2              }
1085   1      //      PWM_debug1 = (unsigned char)uiPWM1Degree;
1086   1      //      PWM_debug2 = (unsigned char)uiPWM2Degree << 4;
1087   1      //      PWM_debug3  = (unsigned char)uiPWM1Degree + (unsigned char)uiPWM2Degree << 4;
1088   1      //      PWM_debug4 = PWM_debug1 + PWM_debug2;
1089   1              //------------------------DEBUG END-------------------------------
1090   1              PWMDEGREE_Low8Bits  = (unsigned char)uiPWM1Degree + ((unsigned char)uiPWM2Degree << 4);
1091   1              PWMDEGREE_HighBit0 = (uiPWM1Degree & 0x100)?1:0;
1092   1              cDebugTmp = (uiPWM1Degree & 0x100)?1:0;
1093   1              PWMDEGREE_HighBit1 = (uiPWM1Degree & 0x200)?1:0;
1094   1              cDebugTmp = (uiPWM1Degree & 0x200)?1:0;
1095   1              
1096   1              PWM1CHANGEORDER =  0;
1097   1              while( PWM1CHANGEORDER != 0 );//wait
1098   1              PWM1CHANGEORDER =  1;
1099   1              PWM2CHANGEORDER =  0;
1100   1              while( PWM2CHANGEORDER != 0 );//wait
1101   1              PWM2CHANGEORDER =  1;
1102   1      }
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 19  

1103          void TouchKeepAlive(void)
1104          {
1105   1              char data SFRPAGE_SAVE =SFRPAGE;
1106   1              SFRPAGE=TIMER01_PAGE;
1107   1              KeepAliveTime_i = 0;
1108   1              ET0 = 1;//Enable Timer0 interrupt
1109   1              TR0 = 1;//Run Timer0
1110   1              SFRPAGE = SFRPAGE_SAVE;
1111   1      }
1112          void LostConnect(void)
1113          {
1114   1              uiPWM1Degree=uiPWM2Degree=0;
1115   1              PWMChange();
1116   1              IN11=0;
1117   1              IN12=0;
1118   1              IN31=0;
1119   1              IN32=0;
1120   1      //      Uart0_TransmitString("lost connect",strlen("lost connect"));
1121   1      //      Acknowledge('s');
1122   1      }
1123          void Acknowledge(unsigned char back)
1124          {
1125   1      Uart0_SendByte(0x54);
1126   1              Uart0_SendByte(back);
1127   1              Uart0_SendByte(1);
1128   1              Uart0_SendByte(back+1);
1129   1              
1130   1              
1131   1      }
1132          void Check_Counter(unsigned int *Counter_L_p, unsigned int *Counter_R_p)
1133          {
1134   1      #ifndef CHECK_COUNTER_DEBUG
1135   1              static unsigned int c_L = 0;
1136   1              static unsigned int c_R = 0;
1137   1                                              char debug = 0;
1138   1      #endif
1139   1              char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
1140   1              SFRPAGE = TMR4_PAGE;                // Set SFR page
1141   1              *Counter_L_p = TMR4H;
1142   1              *Counter_L_p = *Counter_L_p << 8;
1143   1              *Counter_L_p += TMR4L;
1144   1              SFRPAGE = TMR3_PAGE;                // Set SFR page
1145   1              *Counter_R_p = TMR3H;
1146   1              *Counter_R_p = *Counter_R_p << 8;
1147   1              *Counter_R_p += TMR3L;
1148   1              
1149   1              if(*Counter_R_p >= 50000)
1150   1              {
1151   2                      TMR3H = 0;
1152   2                      TMR3L = 0;
1153   2                      *Counter_R_p = 0;
1154   2                      TMR3_1000_circles ++;
1155   2              }
1156   1              if(*Counter_L_p >= 50000)
1157   1              {
1158   2                      SFRPAGE = TMR4_PAGE;                // Set SFR page
1159   2                      TMR4H = 0;
1160   2                      TMR4L = 0;
1161   2                      *Counter_L_p = 0;
1162   2                      TMR4_1000_circles ++;
1163   2              }
1164   1              
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     09/29/2015 16:13:41 PAGE 20  

1165   1      #ifndef CHECK_COUNTER_DEBUG
1166   1              if(*Counter_L_p > c_L )
1167   1              {
1168   2                      c_L = *Counter_L_p;
1169   2              }
1170   1              if(*Counter_R_p > c_R )
1171   1              {
1172   2                      c_R = *Counter_R_p;
1173   2              }
1174   1              if(*Counter_R_p > 2000)
1175   1              {
1176   2                      c_R = *Counter_R_p;
1177   2              }
1178   1      //      if( TMR3_1000_circles > 0 )
1179   1      //      {
1180   1      //              debug ++; 
1181   1      //      }
1182   1      #endif
1183   1              SFRPAGE = SFRPAGE_SAVE;
1184   1      }
1185          
1186          //-----------------------------------------------------------------------------
1187          // End Of File
1188          //-----------------------------------------------------------------------------
*** WARNING C294 IN LINE 462 OF FlashTestMain.c: unreachable code
*** WARNING C294 IN LINE 468 OF FlashTestMain.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2150    ----
   CONSTANT SIZE    =     61    ----
   XDATA SIZE       =    311      30
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  6 WARNING(S),  0 ERROR(S)
