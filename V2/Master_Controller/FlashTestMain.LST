C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE FLASHTESTMAIN
OBJECT MODULE PLACED IN FlashTestMain.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE FlashTestMain.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //-----------------------------------------------------------------------------
   2          // F12x_UART0_Interrupt.c
   3          //-----------------------------------------------------------------------------
   4          // ????????????? RJ ?? ???????
   5          // ???????:     http://dadastudio.taobao.com/ 
   6          // ????????      C8051F12x-13x???.pdf ?? 21 ?:UART0
   7          //
   8          // Copyright 2006 Silicon Laboratories, Inc.
   9          // http://www.silabs.com
  10          //
  11          // Program Description:
  12          //
  13          // This program demonstrates how to configure the C8051F120 to write to and read 
  14          // from the UART interface. The program reads a word using the UART0 interrupts 
  15          // and outputs that word to the screen, with all characters in uppercase
  16          //
  17          // How To Test:
  18          //
  19          // 1) Download code to a 'F12x device that is connected to a UART transceiver
  20          // 2) Verify jumpers J6 and J9 are populated on the 'F12x TB.
  21          // 3) Connect serial cable from the transceiver to a PC
  22          // 4) On the PC, open HyperTerminal (or any other terminal program) and connect
  23          //    to the COM port at <BAUDRATE> and 8-N-1
  24          // 5) Download and execute code on an 'F12x target board.
  25          // 6) Type up to 64 characters into the Terminal and press Enter.  The MCU 
  26          //    will then print back the characters that were typed
  27          //   
  28          //
  29          // Target:         C8051F12x
  30          // Tool chain:     Keil C51 7.50 / Keil EVAL C51
  31          // Command Line:   None
  32          //
  33          // Release 1.0
  34          //    -Initial Revision (SM)
  35          //    -11 JULY 2007
  36          //
  37          //       P5.0-->PWMHigelevel bit0
  38          //       P5.1-->PWMHigelevel bit1
  39          //       P5.2-->PWMHigelevel bit2
  40          //       P5.3-->PWMHigelevel bit3
  41          //   P5.4-->PWMHigelevel bit4
  42          //       P5.5-->PWMHigelevel bit5
  43          //   P5.6-->PWMHigelevel bit6
  44          //       P5.7-->PWMHigelevel bit7
  45          //       P4.6-->PWMHigelevel bit8
  46          //       P4.7-->PWMHigelevel bit9
  47          //       P4.0-->cPWM1ChangeOrder
  48          //   P4.1-->cPWM2ChangeOrder
  49          
  50          //-----------------------------------------------------------------------------
  51          // Includes
  52          //-----------------------------------------------------------------------------
  53          
  54          #include <c8051f120.h>                 // SFR declarations
  55          #include <stdio.h>                     
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 2   

  56          #include <string.h>
  57          #include <F120_FlashPrimitives.h>
  58          #include <math.h>
  59          #include "MyDebug.h"
  60          //-----------------------------------------------------------------------------
  61          // 16-bit SFR Definitions for 'F12x
  62          //-----------------------------------------------------------------------------
  63          
  64          sfr16 RCAP2    = 0xca;                 // Timer2 capture/reload
  65          sfr16 TMR2     = 0xcc;                 // Timer2
  66          
  67          //-----------------------------------------------------------------------------
  68          // Global Constants
  69          //-----------------------------------------------------------------------------
  70          
  71          #define BAUDRATE     9600            // Baud rate of UART in bps
  72          #define UART1BAUDRATE 115200             
  73          #define Const_Control_Time      10                      //ADC cycle = Const_Control_Time*Timer0 cycle = 10*10ms=100ms
  74          sbit PWM1       =       P3^2;                      
  75          sbit IN11               =       P6^3;
  76          sbit IN12               =       P6^4;
  77          sbit TMR3Debug  =   P3^5;
  78          sbit SET                =       P3^1;
  79          sbit Key1               =       P7^2;
  80          sbit PWM3               =       P6^7;
  81          sbit IN31               =       P6^5;
  82          sbit IN32               =       P6^6;
  83          sbit DEBUGPORT  =   P3^0;
  84          sbit PWM1CHANGEORDER = P4^0;
  85          sbit PWM2CHANGEORDER = P4^1;
  86          sbit PWMDEGREE_HighBit0=P4^6;
  87          sbit PWMDEGREE_HighBit1=P4^7;
  88          sbit D0 = P5^0;
  89          sbit D1 = P5^1;
  90          sbit D2 = P5^2;
  91          sbit D3 = P5^3;
  92          sbit D4 = P5^4;
  93          sbit D5 = P5^5;
  94          sbit D6 = P5^6;
  95          sbit D7 = P5^7;
  96          // SYSTEMCLOCK = System clock frequency in Hz
  97          #define SYSTEMCLOCK       (22118400L * 9 / 4)
  98          #define TIMER0CLOCK                     (SYSTEMCLOCK/48)
  99          #define TIMER1CLOCK             (SYSTEMCLOCK/48)
 100          #define TIMER3CLOCK                     (SYSTEMCLOCK/48)
 101          #define MAP_ADC_ANGEL_SIZE  13
 102          #define UART_BUFFERSIZE 64
 103          #define UART1_BUFFERSIZE 22
 104          #define PWMDEGREE_Low8Bits P5
 105          
 106          //--------------------------------POSE & Control-------------------------------------------
 107          #define MAX_PWM 800
 108          #define ANGELRANGE_SIZE 7
 109          #define ANGELSCALE_10 0xF8E3  //-10
 110          #define ANGELSCALE_5 0xFC71  //-5
 111          #define ANGELSCALE_3 0xFDDD  //-3
 112          #define ANGELSCALE0  0x0000  //0
 113          #define ANGELSCALE3  0x0222  //3
 114          #define ANGELSCALE5  0x038E  //5
 115          #define ANGELSCALE10  0x071C  //10
 116          
 117          #define ADJUST_THRESHOLD 100
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 3   

 118          #define PWM_CHG_GAP 100
 119          //-----------------------------------------------------------------------------
 120          // Function Prototypes
 121          //-----------------------------------------------------------------------------
 122          
 123          void Ext_Interrupt_Init (void);
 124          void OSCILLATOR_Init (void);         
 125          void PORT_Init (void);
 126          void UART0_Init (void);
 127          void RerangeTheBufferQueue(unsigned char IndexOfBuffer);
 128          void WirelessModule_Init(void);
 129          void Uart0_SendByte(unsigned char value);
 130          void Uart0_TransmitString(unsigned char * pucString , int iStringSize );
 131          void TIMER0_Init(void);
 132          void TIMER1_Init(unsigned int count);
 133          void Calibration(void);
 134          void Delay_ms(unsigned int count);
 135          void Regulate(void);
 136          void FLASH_ByteWrite (FLADDR addr, char byte, bit SFLE);
 137          unsigned char FLASH_ByteRead (FLADDR addr, bit SFLE);
 138          void FLASH_PageErase (FLADDR addr, bit SFLE);
 139          void SaveMapToFlash(void);
 140          void RestoreMapFromFlash(void);
 141          void Timer3_Init(void);
 142          void Timer4_Init(void);
 143          void UART1_Init (void);
 144          void Uart1_SendByte(unsigned char value);
 145          void PWMChange(unsigned int side_ui, unsigned int PWM_degree);
 146          void TouchKeepAlive(void);
 147          void Acknowledge(unsigned char back);
 148          void LostConnect(void);
 149          void Check_Counter(unsigned int *Counter_L_p, unsigned int *Counter_R_p, unsigned long *Counter_HighBits_a
             -);
 150          void balance_wheel(unsigned int *Counter_L_p, unsigned int *Counter_R_p, unsigned long *Counter_HighBits_a
             -);
 151          //-----------------------------------------------------------------------------
 152          // Global Variables
 153          //-----------------------------------------------------------------------------
 154          
 155          //-------------------------------UART0-----------------------------------------
 156          unsigned int UART0_Receive_Buffer_Size = 0;
 157          unsigned char UART_Receive_Buffer_Queue[UART_BUFFERSIZE]={0};
 158          unsigned char * UART_Receive_Buffer_QueueHead=UART_Receive_Buffer_Queue;
 159          unsigned char * UART_Receive_Buffer_QueueBottom=UART_Receive_Buffer_Queue;
 160          unsigned char UART_Transmit_Buffer_Queue[UART_BUFFERSIZE];
 161          unsigned char * UART_Transmit_Buffer_QueueHead=UART_Transmit_Buffer_Queue;
 162          unsigned char * UART_Transmit_Buffer_QueueBottom=UART_Transmit_Buffer_Queue;
 163          unsigned char TX_Ready =1;
 164          static   char Byte;
 165                           char Rcv_New=0;
 166          //--------------------------------UART1-----------------------------------------
 167          unsigned char   Counter_UART1 = 0;
 168          unsigned char   Flag_NewFrame = 0;
 169          unsigned char   UART1_Receive_Buffer_Queue[UART1_BUFFERSIZE]={0};
 170          unsigned char * UART1_Receive_Buffer_QueueHead   = UART1_Receive_Buffer_Queue;
 171          unsigned char * UART1_Receive_Buffer_QueueBottom  = UART1_Receive_Buffer_Queue;
 172          
 173          
 174          //--------------------------------POSE & Control-------------------------------------------
 175          int a,angle,Temp,w;
 176          int ZeroPoint_a,ZeroPoint_w,ZeroPoint_angle,ZeroPoint_Temp;
 177          int iDeviation = 0;
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 4   

 178          unsigned int uiAbsoluteDeviation =  0;
 179          unsigned int AbsoluteW_ui = 0;
 180          int iStablePoint = 0;
 181          bit RotateDirection = 0;
 182          unsigned int count_L = 0;
 183          unsigned int count_R = 0;
 184          int iAngleRange[] = 0;
 185          struct Pair_Angel_Control{
 186                  int Angel;
 187                  int Kp;
 188                  int Ki;
 189                  int Kd;
 190          };
 191          struct Pair_Angel_Control Map_Angel_PID[ANGELRANGE_SIZE] = {{ANGELSCALE_10,5,0,1},\
 192                                                                                                                                          {ANGELSCALE_5,4,0,1},\
 193                                                                                                                                          {ANGELSCALE_3,3,0,1},\
 194                                                                                                                                          {ANGELSCALE0,1,0,1},\
 195                                                                                                                                          {ANGELSCALE3,2,0,1},\
 196                                                                                                                                          {ANGELSCALE5,3,0,1},\
 197                                                                                                                                          {ANGELSCALE10,5,0,1}};
 198          int iCurrentKey = 0;
 199          unsigned int KeepAliveTime_i=0;
 200          char car_state = 0;  //1 = it is go forwarding state now
 201          //-------------------------------Motor--------------------------------
 202          unsigned int Motor1_Time=0;
 203          unsigned int Motor2_Time=0;
 204          
 205          unsigned int PWM1_HighLevelCount=0;
 206          unsigned int PWM1_LowLevelCount=0;
 207          float fPWM1_HighLevelPercent = 0.5f;
 208          bit pwm1_flag=0;
 209          
 210          unsigned int PWM3_HighLevelCount=0;
 211          unsigned int PWM3_LowLevelCount=0;
 212          float fPWM3_HighLevelPercent = 0.9f;
 213          bit pwm3_flag=0;
 214          
 215          unsigned char TH1_HighLevelPrefetch = 0;
 216          unsigned char TL1_HighLevelPrefetch = 0;
 217          unsigned char TMRH3_HighLevelPrefetch = 0;
 218          unsigned char TMRL3_HighLevelPrefetch = 0;
 219          
 220          unsigned char TH1_LowLevelPrefetch = 0;
 221          unsigned char TL1_LowLevelPrefetch = 0;
 222          unsigned char TMRH3_LowLevelPrefetch = 0;
 223          unsigned char TMRL3_LowLevelPrefetch = 0;
 224          
 225          unsigned int uiPWM1Degree=0;
 226          unsigned int uiPWM2Degree=0;
 227          bit     PWM1ChangeOrder = 0;
 228          bit     PWM2ChangeOrder = 0;
 229          
 230          char cOldRotateDirection = 0;
 231          //-------------------------------System--------------------------------
 232          char data Global_SFRPAGE_SAVE;
 233          //unsigned int i=0;
 234          char cDebugTmp=0;
 235          char Control_TimeIsUp = 0;
 236          unsigned char Control_Time=0;
 237          
 238          
 239          unsigned char TH0_Prefetch = 0;
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 5   

 240          unsigned char TL0_Prefetch = 0;
 241          unsigned char PWM_debug1 = 0;
 242          unsigned char PWM_debug2 = 0;
 243          unsigned char PWM_debug3 = 0;
 244          unsigned char PWM_debug4 = 0;
 245          //unsigned int TMR3_1000_circles = 0;
 246          //unsigned int TMR4_1000_circles = 0;
 247          
 248          //-----------------------------------------------------------------------------
 249          // main() Routine
 250          //-----------------------------------------------------------------------------
 251          
 252          void main (void)
 253          {
 254   1              unsigned int Counter_L =0;
 255   1              unsigned int *Counter_L_p = &Counter_L;
 256   1              unsigned int Counter_R = 0;
 257   1              unsigned int *Counter_R_p = &Counter_R;
 258   1              unsigned long Counter_HighBits_a[2] = {0,0};
 259   1              //Initialization
 260   1              SFRPAGE = CONFIG_PAGE;
 261   1              WDTCN = 0xDE;                       // Disable watchdog timer
 262   1              WDTCN = 0xAD;
 263   1              OSCILLATOR_Init();  
 264   1              PORT_Init();                       // Initialize crossbar and GPIO
 265   1              UART0_Init();                      // Initialize UART0
 266   1      //      UART1_Init();
 267   1              WirelessModule_Init();
 268   1              TIMER0_Init();
 269   1      //      Ext_Interrupt_Init();
 270   1              Timer4_Init();
 271   1              Timer3_Init();
 272   1              EA = 1;
 273   1      
 274   1              //*************flash test**********************
 275   1      //      FLASH_PageErase(0x8000,1);
 276   1      //      for(i=0;i<MAP_ADC_ANGEL_SIZE;i++)
 277   1      //      {
 278   1      //              Map_ADC_Angel_array[i].ADC = i;
 279   1      //              Map_ADC_Angel_array[i].Angel = -i;
 280   1      //      }
 281   1      //      SaveMapToFlash();
 282   1      //      FLASH_PageErase(0x8000,1);
 283   1      //      FLASH_ByteWrite(0x8000,'j',1);
 284   1      //      FLASH_ByteWrite(0x8001,'a',1);
 285   1      //      cReadFlash = FLASH_ByteRead(0x8000,1);
 286   1      ////*******************PWM test******************
 287   1      //      uiPWM1Degree = 0;
 288   1      //      while(1)
 289   1      //      {
 290   1      //              uiPWM1Degree +=50;
 291   1      //              PWMChange(1);
 292   1      //              PWMChange(2);
 293   1      //      }
 294   1      ////-------------------PWM test------------------
 295   1              
 296   1              
 297   1      
 298   1      
 299   1              Uart0_TransmitString("Ready",strlen("Ready"));
 300   1              while (1)
 301   1              {
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 6   

 302   2      //              /******Debug********/
 303   2      //              PWMChange();
 304   2      //              /******End**********/
 305   2                      
 306   2                      //if more than 20*50ms=1000ms is past since last message.
 307   2                      if(KeepAliveTime_i > 100)
 308   2                      {
 309   3                              LostConnect();
 310   3                      }
 311   2                      if(UART_Receive_Buffer_QueueHead < UART_Receive_Buffer_QueueBottom)
 312   2                      {
 313   3                              //Uart0_SendByte(*UART_Receive_Buffer_Queue);
 314   3                              //++UART_Receive_Buffer_Queue;
 315   3                              if( 0x53 == *UART_Receive_Buffer_QueueHead )
 316   3                              {
 317   4                                      char WaitFailSign = 0;
 318   4                                      ++UART_Receive_Buffer_QueueHead;
 319   4                                      while( UART_Receive_Buffer_QueueBottom - UART_Receive_Buffer_QueueHead < 3 )
 320   4                                      {
 321   5                                              //wait the rest three char
 322   5                                              if(KeepAliveTime_i > 100)
 323   5                                              {
 324   6                                                      //wait too long 
 325   6                                                      WaitFailSign = 1;
 326   6                                                      break;
 327   6                                              }
 328   5                                      }
 329   4                                      if(WaitFailSign == 1) 
 330   4                                      {
 331   5                                              //wait too long. Abort this frame. 
 332   5                                              UART_Receive_Buffer_QueueHead = UART_Receive_Buffer_QueueHead;
 333   5                                              break;
 334   5                                      }
 335   4                                      
 336   4                                      //check the sum 
 337   4                                      if( *UART_Receive_Buffer_QueueHead + *(UART_Receive_Buffer_QueueHead+1) != *(UART_Receive_Buffer_Queue
             -Head+2) )
 338   4                                      {
 339   5                                              /*debug*/
 340   5                                              Uart0_SendByte('w');
 341   5                                              UART_Receive_Buffer_QueueHead+=3;
 342   5                                              /*debug end*/
 343   5                                              continue;
 344   5                                      }
 345   4                                      
 346   4                                      
 347   4                                      
 348   4                                      //next char (order) come
 349   4                                      car_state = *UART_Receive_Buffer_QueueHead;
 350   4                                      switch(*UART_Receive_Buffer_QueueHead)
 351   4                                      {
 352   5      //                                      case 'g'://start the car
 353   5      //                                              uiPWM1Degree=uiPWM2Degree=*(UART_Receive_Buffer_QueueHead+1);
 354   5      //                                              PWMChange();
 355   5      //                                              IN11=1;
 356   5      //                                              IN12=0;
 357   5      //                                              IN31=1;
 358   5      //                                              IN32=0;
 359   5      //                                              TouchKeepAlive();
 360   5      //                                              Acknowledge(*UART_Receive_Buffer_QueueHead);
 361   5      //                                              break;
 362   5                                              case 'f'://forward
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 7   

 363   5                                                      uiPWM1Degree=uiPWM2Degree=*(UART_Receive_Buffer_QueueHead+1);
 364   5      //                                              PWMChange(1, uiPWM1Degree * 64 -1);     
 365   5      //                                              PWMChange(2, uiPWM2Degree * 64 -1);                                                     
 366   5      //                                              IN11=1;
 367   5      //                                              IN12=0;
 368   5      //                                              IN31=1;
 369   5      //                                              IN32=0;
 370   5      //                                              if(uiPWM1Degree > 4)
 371   5      //                                              {
 372   5      //                                                      uiPWM1Degree = 4;
 373   5      //                                              }
 374   5                                                      TouchKeepAlive();
 375   5                                                      Acknowledge(*UART_Receive_Buffer_QueueHead);
 376   5                                                      break;
 377   5                                              case 'l'://turn left
 378   5                                                      uiPWM1Degree=uiPWM2Degree=*(UART_Receive_Buffer_QueueHead+1);
 379   5                                                      PWMChange(1, uiPWM1Degree * 64 -1);     
 380   5                                                      PWMChange(2, uiPWM2Degree * 64 -1);     
 381   5                                                      IN11=0;
 382   5                                                      IN12=0;
 383   5                                                      IN31=1;
 384   5                                                      IN32=0;
 385   5                                                      TouchKeepAlive();
 386   5                                                      Acknowledge(*UART_Receive_Buffer_QueueHead);
 387   5                                                      break;
 388   5                                              case 'r'://turn right
 389   5                                                      uiPWM1Degree=uiPWM2Degree=*(UART_Receive_Buffer_QueueHead+1);
 390   5                                                      PWMChange(1, uiPWM1Degree * 64 -1);     
 391   5                                                      PWMChange(2, uiPWM2Degree * 64 -1);                                             
 392   5                                                      IN11=1;
 393   5                                                      IN12=0;
 394   5                                                      IN31=0;
 395   5                                                      IN32=0;
 396   5                                                      TouchKeepAlive();
 397   5                                                      Acknowledge(*UART_Receive_Buffer_QueueHead);
 398   5                                                      break;
 399   5                                              case 'b'://go back
 400   5                                                      uiPWM1Degree=uiPWM2Degree=*(UART_Receive_Buffer_QueueHead+1);
 401   5                                                      PWMChange(1, uiPWM1Degree * 64 -1);     
 402   5                                                      PWMChange(2, uiPWM2Degree * 64 -1);
 403   5                                                      IN11=0;
 404   5                                                      IN12=1;
 405   5                                                      IN31=0;
 406   5                                                      IN32=1;
 407   5                                                      TouchKeepAlive();
 408   5                                                      Acknowledge(*UART_Receive_Buffer_QueueHead);
 409   5                                                      break;
 410   5                                              case 's'://stop
 411   5                                                      uiPWM1Degree=uiPWM2Degree=0;
 412   5                                                      PWMChange(1, 0);        
 413   5                                                      PWMChange(2, 0);
 414   5                                                      IN11=0;
 415   5                                                      IN12=0;
 416   5                                                      IN31=0;
 417   5                                                      IN32=0;
 418   5                                                      TouchKeepAlive();
 419   5                                                      Acknowledge(*UART_Receive_Buffer_QueueHead);
 420   5                                                      break;
 421   5                                              default:
 422   5                                                      /*debug*/
 423   5                                                      Acknowledge('n');//No such order
 424   5                                                      /*debug end*/
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 8   

 425   5                                                      break;                                          
 426   5                                      }
 427   4                                      UART_Receive_Buffer_QueueHead+=3;
 428   4                              }
 429   3                              else
 430   3                              {
 431   4                                      ++UART_Receive_Buffer_QueueHead;
 432   4                              }
 433   3                              
 434   3                      }       
 435   2                      // Get the counter information
 436   2                      Check_Counter(Counter_L_p, Counter_R_p, Counter_HighBits_a);
 437   2                      balance_wheel(Counter_L_p, Counter_R_p, Counter_HighBits_a);
 438   2              }
 439   1      }
 440          
 441          //-----------------------------------------------------------------------------
 442          // Initialization Subroutines
 443          //-----------------------------------------------------------------------------
 444          
 445          //-----------------------------------------------------------------------------
 446          // OSCILLATOR_Init
 447          //-----------------------------------------------------------------------------
 448          //
 449          // Return Value : None
 450          // Parameters   : None
 451          //
 452          // This function initializes the system clock to use the PLL as its clock
 453          // source, where the PLL multiplies the external 22.1184MHz crystal by 9/4.
 454          //
 455          //-----------------------------------------------------------------------------
 456          void OSCILLATOR_Init (void)
 457          {
 458   1         int i=0;                              // Software timer
 459   1      
 460   1         char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 461   1      
 462   1         SFRPAGE = CONFIG_PAGE;              // Set SFR page
 463   1      
 464   1         OSCICN = 0x80;                      // Set internal oscillator to run
 465   1                                             // at its slowest frequency
 466   1      
 467   1         CLKSEL = 0x00;                      // Select the internal osc. as
 468   1                                             // the SYSTEMCLOCK source
 469   1      
 470   1         // Initialize external crystal oscillator to use 22.1184 MHz crystal
 471   1      
 472   1         OSCXCN = 0x67;                      // Enable external crystal osc.
 473   1          for(i=0; i < 256; ) // Wait at least 1ms
 474   1              {
 475   2                      i++;
 476   2              }
 477   1         while (!(OSCXCN & 0x80));           // Wait for crystal osc to settle
 478   1      
 479   1         SFRPAGE = LEGACY_PAGE;
 480   1         FLSCL |=  0x30;                     // Initially set FLASH read timing for
 481   1                                             // 100MHz SYSTEMCLOCK (most conservative
 482   1                                             // setting)
 483   1         if (SYSTEMCLOCK <= 25000000L) {           
 484   2         // Set FLASH read timing for <=25MHz
 485   2            FLSCL &= ~0x30;
 486   2         } else if (SYSTEMCLOCK <= 50000000L) {    
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 9   

 487   2         // Set FLASH read timing for <=50MHz
 488   2            FLSCL &= ~0x20;
 489   2         } else if (SYSTEMCLOCK <= 75000000L) {    
 490   2         // Set FLASH read timing for <=75MHz
 491   2            FLSCL &= ~0x10;
 492   2         } else {                            // set FLASH read timing for <=100MHz
 493   2            FLSCL &= ~0x00;
 494   2         }
 495   1      
 496   1         // Start PLL for 50MHz operation
 497   1         SFRPAGE = PLL0_PAGE;
 498   1         PLL0CN = 0x04;                      // Select EXTOSC as clk source
 499   1         PLL0CN |= 0x01;                     // Enable PLL power
 500   1         PLL0DIV = 0x04;                     // Divide by 4
 501   1         PLL0FLT &= ~0x0f;
 502   1         PLL0FLT |=  0x0f;                   // Set Loop Filt for (22/4)MHz input clock
 503   1         PLL0FLT &= ~0x30;                   // Set ICO for 30-60MHz
 504   1         PLL0FLT |=  0x10;
 505   1      
 506   1         PLL0MUL = 0x09;                     // Multiply by 9
 507   1      
 508   1         // wait at least 5us
 509   1         for (i = 0; i < 256; )
 510   1         {
 511   2                 i++;
 512   2         }
 513   1      
 514   1         PLL0CN |= 0x02;                     // Enable PLL
 515   1      
 516   1         while (PLL0CN & 0x10 == 0x00);      // Wait for PLL to lock
 517   1      
 518   1         SFRPAGE = CONFIG_PAGE;
 519   1      
 520   1         CLKSEL = 0x02;                      // Select PLL as SYSTEMCLOCK source
 521   1      
 522   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFRPAGE
 523   1      }
 524          
 525          //-----------------------------------------------------------------------------
 526          // PORT_Init
 527          //-----------------------------------------------------------------------------
 528          //
 529          // Return Value : None
 530          // Parameters   : None
 531          //
 532          // This function configures the crossbar and GPIO ports.
 533          //
 534          // P0.0   digital   push-pull     UART TX
 535          // P0.1   digital   open-drain    UART RX
 536          //-----------------------------------------------------------------------------
 537          void PORT_Init (void)
 538          {
 539   1              char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 540   1      
 541   1              SFRPAGE = CONFIG_PAGE;              // Set SFR page
 542   1      
 543   1              XBR0     = 0x04;                    // Enable UART0
 544   1      //      XBR0    |= 0x08;                     // Route CEX0 to P0.2
 545   1              
 546   1              XBR1     = 0x20;                                        //Enable T2
 547   1              XBR2     = 0x40;                    // Enable crossbar and weak pull-up
 548   1              XBR2    |= 0X08;                                        //Enable T4
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 10  

 549   1      //      XBR1     = 0x04 + 0x10;                         //Enable /INT0 and /INT1
 550   1              XBR2    |= 0x04;                                        //Enable UART1
 551   1       //   P1MDIN   = 0xFF;                                   
 552   1              P0MDOUT |= 0x04;                    // Set CEX0 (P0.2) to push-pull
 553   1              P0MDOUT |= 0x01;                    // Set TX pin to push-pull
 554   1              P0MDOUT |= 0x04;                                        //Set UART1 TX pin to push-pull
 555   1      
 556   1              P3MDOUT = 0x18;                                         // P3.3 P3.4 is  push-pull
 557   1      //      P6MDOUT = 0x60;                                         // P6.x is push-pull
 558   1              P6              &= ~0x80;
 559   1              P6MDOUT = 0xFF;
 560   1              P5MDOUT = 0xFF;                                         //P6 is push-pull
 561   1              P4MDOUT = 0xC3;                                         //P4.7,4.6,4.0,4.1 is push-pull
 562   1      //      P7MDOUT = 0x00;                                         //P7.x is  open-drain
 563   1              SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 564   1      }
 565          
 566          //-----------------------------------------------------------------------------
 567          // TIMER0_Init
 568          //-----------------------------------------------------------------------------
 569          //
 570          //
 571          //-----------------------------------------------------------------------------
 572          void TIMER0_Init(void)
 573          {
 574   1      
 575   1              char data SFRPAGE_SAVE =SFRPAGE;
 576   1              SFRPAGE=TIMER01_PAGE;
 577   1              TCON &= ~0x30;//stop the timer0
 578   1              TMOD &= ~0x00;//Set the timer0 work in mode of hex
 579   1              TMOD |= 0x01;
 580   1              CKCON &= 0xf0;
 581   1              CKCON |= 0x02;
 582   1              CKCON &= ~0x08;//Timer 0 uses the clock defined by the prescale bits
 583   1              TR0 = 0;
 584   1              TH0= (0xFFFF-TIMER0CLOCK/20)>>8; //Timer0 cycle = 50ms
 585   1              TL0=  0xFFFF-TIMER0CLOCK/20;
 586   1              ET0 = 1;//Enable interrupt
 587   1              TR0 = 1;//Run Timer0
 588   1              SFRPAGE = SFRPAGE_SAVE;
 589   1      }
 590          
 591          //-----------------------------------------------------------------------------
 592          // TIMER1_Init
 593          //-----------------------------------------------------------------------------
 594          //
 595          // Return Value : None
 596          // Parameters   :
 597          //   1)  int counts - calculated Timer overflow rate
 598          //                    range is postive range of integer: 0 to 32767
 599          //
 600          // Configure Timer1 to auto-reload at interval specified by <counts> (no
 601          // interrupt generated) using SYSCLK as its time base.
 602          //
 603          //-----------------------------------------------------------------------------
 604          //void TIMER1_Init(unsigned int count)
 605          //{
 606          //      char data SFRPAGE_SAVE =SFRPAGE;
 607          //      PWM1_HighLevelCount = count * fPWM1_HighLevelPercent;
 608          //      PWM1_LowLevelCount = (float)count * (1-fPWM1_HighLevelPercent);
 609          //      SFRPAGE=TIMER01_PAGE;
 610          //      TCON &= ~0xC0;//stop the timer1
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 11  

 611          //      TMOD &= ~0x00;//Set the timer1 work in mode of hex
 612          //      TMOD |= 0x10;
 613          //      
 614          //      CKCON &=0x0f;//clear CKCON bit4~7
 615          //      CKCON |= 0x10;//Timer 1 use SYSTEMCLOCK
 616          //      
 617          //      TH1_HighLevelPrefetch = ( 0xffff - (unsigned int) (count * fPWM1_HighLevelPercent) )>>8;
 618          //      TL1_HighLevelPrefetch =   0xffff - (unsigned int) (count * fPWM1_HighLevelPercent) ;
 619          //      TH1_LowLevelPrefetch = (  0xffff - (unsigned int )( count * (1-fPWM1_HighLevelPercent) )  )>>8;
 620          //      TL1_LowLevelPrefetch =    0xffff - (unsigned int) (count * (1-fPWM1_HighLevelPercent));
 621          //      ET1 = 1;//Enable interrupt;
 622          //      TCON |= 0xC0;//start the timer1
 623          //      
 624          //      SFRPAGE = SFRPAGE_SAVE;
 625          //}
 626          
 627          //-----------------------------------------------------------------------------
 628          // TIMER3_Init
 629          //-----------------------------------------------------------------------------
 630          void Timer3_Init(void)
 631          {
 632   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 633   1      
 634   1              SFRPAGE = TMR3_PAGE;                // Set SFR page
 635   1              TMR3CF  = 0x00;
 636   1              TMR3CN  = 0x00;
 637   1              TMR3CN  = 0x02;                                         //Counter mode
 638   1      //      tmp=TMR3CN;
 639   1      //      TMR3CF &= ~0x18;                    // Timer3 uses SYSCLK/12
 640   1              TMR3L = 0x00;                       // Init the Timer3 register
 641   1              TMR3H = 0x00;
 642   1              TMR3CN |= 0x04;                      // Enable Counter3
 643   1      //      ET4 = 1;                            // Timer4 interrupt enabled
 644   1              TR3 = 1;
 645   1              
 646   1              SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 647   1      }
 648          void Timer4_Init(void)
 649          {
 650   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 651   1      
 652   1              SFRPAGE = TMR4_PAGE;                // Set SFR page
 653   1              TMR4CF  = 0x00;
 654   1              TMR4CN  = 0x00;
 655   1              TMR4CN  = 0x02;                                         //Counter mode
 656   1      //      tmp=TMR4CN;
 657   1              TMR4L = 0x00;                      
 658   1              TMR4H = 0x00;
 659   1              TMR4CN |= 0x04;                      // Enable Counter4
 660   1      //      ET4 = 1;                            // Timer4 interrupt enabled
 661   1              TR4 = 1;
 662   1              
 663   1              SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 664   1      }
 665          //void Timer3_ISR(void) interrupt 14
 666          //{
 667          //      char data SFRPAGE_SAVE =SFRPAGE;//Save current SFP page
 668          //      SFRPAGE = TMR3_PAGE;
 669          //      TMR3Debug = ~TMR3Debug;
 670          
 671          //      
 672          //      if( Control_Time == 0 )
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 12  

 673          //      {
 674          //              Control_Time = Const_Control_Time;
 675          //              Control_TimeIsUp=1;
 676          ////            /***************Debug Begin***********************/
 677          ////            IN31 ^= 1;
 678          ////            //---------------Debug End ---------------------------
 679          //      }
 680          //      else
 681          //      {
 682          //              Control_Time--;
 683          //      }
 684          //      TMR3CN &= ~0x80;//clear interrupt flag
 685          //      SFRPAGE=Global_SFRPAGE_SAVE;
 686          //      SFRPAGE = SFRPAGE_SAVE;
 687          //}
 688          
 689          //-----------------------------------------------------------------------------
 690          // UART0_Init   Variable baud rate, Timer 2, 8-N-1
 691          //-----------------------------------------------------------------------------
 692          //
 693          // Return Value : None
 694          // Parameters   : None
 695          //
 696          // Configure UART0 for operation at <baudrate> 8-N-1 using Timer2 as
 697          // baud rate source.
 698          //
 699          //-----------------------------------------------------------------------------
 700          void UART0_Init (void)
 701          {
 702   1         char SFRPAGE_SAVE;
 703   1      
 704   1         SFRPAGE_SAVE = SFRPAGE;             // Preserve SFRPAGE
 705   1      
 706   1         SFRPAGE = TMR2_PAGE;
 707   1      
 708   1         TMR2CN = 0x00;                      // Timer in 16-bit auto-reload up timer
 709   1                                             // mode
 710   1         TMR2CF = 0x08;                      // SYSCLK is time base; no output;
 711   1                                             // up count only
 712   1         RCAP2 = - ((long) SYSTEMCLOCK/BAUDRATE/16);
 713   1         TMR2 = RCAP2;
 714   1         TR2= 1;                             // Start Timer2
 715   1      
 716   1         SFRPAGE = UART0_PAGE;
 717   1      
 718   1         SCON0 = 0x50;                       // 8-bit variable baud rate;
 719   1                                             // 9th bit ignored; RX enabled
 720   1                                             // clear all flags
 721   1         SSTA0 = 0x15;                       // Clear all flags; enable baud rate
 722   1                                             // doubler (not relevant for these
 723   1                                             // timers);
 724   1                                             // Use Timer2 as RX and TX baud rate
 725   1                                             // source;
 726   1         ES0 = 1;  
 727   1         IP |= 0x10;
 728   1      
 729   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFRPAGE
 730   1      }
 731          
 732          
 733          //-----------------------------------------------------------------------------
 734          // Interrupt Service Routines
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 13  

 735          //-----------------------------------------------------------------------------
 736          
 737          //-----------------------------------------------------------------------------
 738          // Timer0_ISR
 739          //-----------------------------------------------------------------------------
 740          //
 741          //
 742          //-----------------------------------------------------------------------------
 743          void Timer0_ISR(void) interrupt 1
 744          {       
 745   1              Global_SFRPAGE_SAVE=SFRPAGE;//Save current SFP page
 746   1              SFRPAGE=CONFIG_PAGE;
 747   1              KeepAliveTime_i++;
 748   1              
 749   1              TF0=0;
 750   1              SFRPAGE=Global_SFRPAGE_SAVE;
 751   1      }
 752          //-----------------------------------------------------------------------------
 753          // Timer1_ISR
 754          //-----------------------------------------------------------------------------
 755          //
 756          //
 757          //-----------------------------------------------------------------------------
 758          //void Timer1_ISR(void) interrupt 3
 759          //{
 760          //      char data SFRPAGE_SAVE =SFRPAGE;//Save current SFP page
 761          //      if(!pwm1_flag)
 762          //      {
 763          //                      
 764          //              //Start of High level
 765          //                      pwm1_flag = 1;  //Set flag
 766          //                      SFRPAGE=CONFIG_PAGE;
 767          //                      PWM1 = 1;       //Set PWM o/p pin
 768          //                      
 769          //                      TH1 = TH1_HighLevelPrefetch;    //Load timer
 770          //                      TL1 = TL1_HighLevelPrefetch;
 771          //                      TF0 = 0;                //Clear interrupt flag
 772          //                      SFRPAGE=SFRPAGE_SAVE;
 773          //                      return;         //Return
 774          //      }
 775          //      else
 776          //      {       //Start of Low level
 777          //              pwm1_flag = 0;  //Clear flag
 778          //              SFRPAGE=CONFIG_PAGE;
 779          //              PWM1 = 0;       //Clear PWM o/p pin
 780          //              
 781          //              TH1 = TH1_LowLevelPrefetch;     //Load timer
 782          //              TL1 = TL1_LowLevelPrefetch;
 783          //              TF0 = 0;        //Clear Interrupt flag
 784          //              
 785          //              SFRPAGE=SFRPAGE_SAVE;
 786          //              return;         //return
 787          //      }
 788          //}
 789          
 790          //void Timer3_ISR(void) interrupt 14
 791          //{
 792          //      char data SFRPAGE_SAVE =SFRPAGE;//Save current SFP page
 793          //      if(!pwm3_flag)
 794          //      {
 795          //                      
 796          //              //Start of High level
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 14  

 797          //                      pwm3_flag = 1;  //Set flag
 798          //                      SFRPAGE = CONFIG_PAGE;
 799          //                      PWM3 = 1;       //Set PWM o/p pin
 800          //              
 801          //                      SFRPAGE = TMR3_PAGE;
 802          //                      TMR3H = TMRH3_HighLevelPrefetch;        //Load timer
 803          //                      TMR3L = TMRL3_HighLevelPrefetch;
 804          //                                              
 805          //                      TF3 = 0;                //Clear interrupt flag
 806          //              
 807          //                      SFRPAGE = SFRPAGE_SAVE;
 808          //                      return;
 809          //      }
 810          //      else
 811          //      {       //Start of Low level
 812          //              pwm3_flag = 0;  //Clear flag
 813          //              
 814          //              SFRPAGE = CONFIG_PAGE;
 815          //              PWM3 = 0;       //Set PWM o/p pin
 816          //              
 817          //              SFRPAGE = TMR3_PAGE;
 818          //              TMR3H = TMRH3_LowLevelPrefetch; //Load timer
 819          //              TMR3L = TMRL3_LowLevelPrefetch;
 820          //              
 821          //              
 822          //              TF3 = 0;        //Clear Interrupt flag
 823          //              
 824          //              SFRPAGE = SFRPAGE_SAVE;
 825          //              return; 
 826          //      }
 827          //}
 828          //-----------------------------------------------------------------------------
 829          // UART0_Interrupt
 830          //-----------------------------------------------------------------------------
 831          //
 832          // This routine is invoked whenever a character is entered or displayed on the
 833          // Hyperterminal.
 834          //
 835          //-----------------------------------------------------------------------------
 836          
 837          void UART0_Interrupt (void) interrupt 4
 838          {
 839   1         SFRPAGE = UART0_PAGE;
 840   1      
 841   1         if ( RI0 == 1 ) //if the buffer is not full
 842   1         {
 843   2            
 844   2                      Byte = SBUF0;                      // Read a character from UART
 845   2                      //if the buffer is't full
 846   2                  if(  (UART_Receive_Buffer_QueueBottom-UART_Receive_Buffer_QueueHead) < UART_BUFFERSIZE )
 847   2                  {
 848   3                          if ( UART_Receive_Buffer_QueueBottom < (UART_Receive_Buffer_Queue+UART_BUFFERSIZE) )
 849   3                              {
 850   4                                      *UART_Receive_Buffer_QueueBottom = Byte; // Store in array
 851   4                                      UART_Receive_Buffer_QueueBottom++;
 852   4                                      if( UART_Receive_Buffer_QueueBottom >= (UART_Receive_Buffer_Queue+UART_BUFFERSIZE) )
 853   4                                              RerangeTheBufferQueue('r');
 854   4                                      Rcv_New=1;//Notice new message come
 855   4                                      UART0_Receive_Buffer_Size++;
 856   4                              }
 857   3                              else
 858   3                                      RerangeTheBufferQueue('r');
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 15  

 859   3                  }
 860   2                  RI0 = 0;                           // Clear interrupt flag
 861   2         }
 862   1      
 863   1         if (TI0 == 1)                   // Check if transmit flag is set
 864   1         {
 865   2                 TX_Ready = 1;
 866   2                 TI0 = 0;
 867   2      //      if ( UART_Transmit_Buffer_QueueHead < UART_Transmit_Buffer_QueueBottom )         // If buffer not 
             -empty
 868   2      //      {
 869   2      ////         Byte = UART_Buffer[UART_Output_First];
 870   2      ////         if ((Byte >= 0x61) && (Byte <= 0x7A)) { // If upper case letter
 871   2      ////            Byte -= 32; }
 872   2      ////                                    int count = UART_Transmit_Buffer_QueueBottom - UART_Transmit_Buffer_QueueHead;
 873   2      ////                                    for(;count>0;count--)
 874   2      ////                                    {
 875   2      ////                                            Uart0_SendByte(*UART_Transmit_Buffer_QueueHead);  // Transmit to Hyperterminal
 876   2      ////                                        UART_Transmit_Buffer_QueueHead++;
 877   2      ////                                    }
 878   2      ////              while( UART_Transmit_Buffer_QueueHead < UART_Transmit_Buffer_QueueBottom )
 879   2      ////              {
 880   2      //                        TI0 = 0;
 881   2      //                        SBUF0 = *UART_Transmit_Buffer_QueueHead;
 882   2      //                        while( !TI0 );
 883   2      //                        ++UART_Transmit_Buffer_QueueHead;
 884   2      ////              }
 885   2      //      }
 886   2      //      else
 887   2      //        {
 888   2      //                TX_Ready = 1;                    // Indicate transmission complete
 889   2      //                TI0 = 0;                           // Clear interrupt flag
 890   2      //        }
 891   2         }
 892   1      }
 893          //-----------------------------------------------------------------------------
 894          // UART1_Interrupt
 895          //-----------------------------------------------------------------------------
 896          //
 897          // This routine is invoked whenever a character is entered or displayed on the
 898          // Hyperterminal.
 899          //
 900          //-----------------------------------------------------------------------------
 901          
 902          
 903          
 904          //-----------------------------------------------------------------------------
 905          // RerangeTheBufferQueue
 906          //-----------------------------------------------------------------------------
 907          //
 908          // This routine is invoked to rerange the UART buffer queue when the bottom point has get to the bottom li
             -mit
 909          //-----------------------------------------------------------------------------
 910          void RerangeTheBufferQueue( char IndexOfBuffer)
 911          {
 912   1              if( IndexOfBuffer == 'r')//rerange the receive buffer
 913   1              {
 914   2                      int count = UART_Receive_Buffer_QueueBottom-UART_Receive_Buffer_QueueHead;
 915   2                      int i=0;
 916   2                      for(i=0;i<count;i++)
 917   2                      {
 918   3                                      *(UART_Receive_Buffer_Queue+i)= UART_Receive_Buffer_QueueHead;
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 16  

*** WARNING C260 IN LINE 918 OF FlashTestMain.c: '=': pointer truncation
 919   3                                      UART_Receive_Buffer_QueueHead++;
 920   3                                      
 921   3                      }
 922   2                      UART_Receive_Buffer_QueueHead=UART_Receive_Buffer_Queue;
 923   2                      UART_Receive_Buffer_QueueBottom=UART_Receive_Buffer_QueueHead+count;
 924   2              }
 925   1              
 926   1              if( IndexOfBuffer == 't')//rerange the transmit buffer
 927   1              {
 928   2                      int count = UART_Transmit_Buffer_QueueBottom-UART_Transmit_Buffer_QueueHead;
 929   2                      int i=0;  
 930   2                      for(i=0;i<count;i++)
 931   2                      {
 932   3                                      *(UART_Transmit_Buffer_Queue+i)= UART_Transmit_Buffer_QueueHead;
*** WARNING C260 IN LINE 932 OF FlashTestMain.c: '=': pointer truncation
 933   3                                      UART_Transmit_Buffer_QueueHead++;
 934   3                                      
 935   3                      }
 936   2                      UART_Transmit_Buffer_QueueHead=UART_Transmit_Buffer_Queue;
 937   2                      UART_Transmit_Buffer_QueueBottom=UART_Transmit_Buffer_QueueHead+count;
 938   2              }       
 939   1      }
 940          //-----------------------------------------------------------------------------
 941          // WirelessModule_Init
 942          //-----------------------------------------------------------------------------
 943          //
 944          //-----------------------------------------------------------------------------
 945          void WirelessModule_Init(void)
 946          {
 947   1              SET=1; // Enter the SET mode of the wireless module
 948   1              memset( UART_Transmit_Buffer_Queue,0,sizeof(UART_Transmit_Buffer_Queue) );
 949   1      }
 950          //-----------------------------------------------------------------------------
 951          // Uart0_SendByte
 952          //-----------------------------------------------------------------------------
 953          //
 954          //-----------------------------------------------------------------------------
 955          void Uart0_SendByte(unsigned char value)
 956          {
 957   1              char data SFRPAGE_SAVE = SFRPAGE;//save current SFR page
 958   1              int i = 0;
 959   1              SFRPAGE = UART0_PAGE;
 960   1      //      //Check if the uart transmit is ready
 961   1      //      while(1)
 962   1      //      {
 963   1      //              if( TI0 == 0 && TX_Ready == 1)
 964   1      //              {
 965   1      //                      break;
 966   1      //              }
 967   1      //      }
 968   1      //      
 969   1      //      //Check if there are enough space
 970   1      //      if( UART_Transmit_Buffer_QueueBottom - UART_Transmit_Buffer_Queue >= UART_BUFFERSIZE )
 971   1      //      {
 972   1      //              RerangeTheBufferQueue('t');
 973   1      //      }
 974   1      //      //Write the Byte to the Transmit queue
 975   1      //      *UART_Transmit_Buffer_QueueBottom = value;
 976   1      //      ++UART_Transmit_Buffer_QueueBottom;
 977   1      //      //Set the TI0 
 978   1      //      TI0 = 1;
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 17  

 979   1          while( TX_Ready == 0 );
 980   1              
 981   1              TI0 = 0;
 982   1              TX_Ready = 0;
 983   1              SBUF0 = value;
 984   1              while(!TX_Ready)
 985   1              {
 986   2                      ;
 987   2              }
 988   1              SFRPAGE = SFRPAGE_SAVE;//Recover the SFR Page
 989   1      }
 990          //-----------------------------------------------------------------------------
 991          // Calibration
 992          //-----------------------------------------------------------------------------
 993          //
 994          //-----------------------------------------------------------------------------
 995          //void Calibration(void)
 996          //{
 997          //      char a_flag = 0,w_flag = 0,angle_flag = 0;
 998          //      UART0_Receive_Buffer_Size = UART_Receive_Buffer_QueueBottom - UART_Receive_Buffer_QueueHead;
 999          ////    strcat(UART_Transmit_Buffer_QueueHead,"ReadyToAdjust");
1000          ////    UART_Transmit_Buffer_QueueBottom += strlen("ReadyToAdjust");
1001          //      Uart0_SendByte('R');
1002          //      
1003          ////    Global_SFRPAGE_SAVE = SFRPAGE;
1004          ////    SFRPAGE = ADC0_PAGE;
1005          ////    TX_Ready = 0;                  // Set the flag to zero
1006          ////    TI0 = 1;                       // Set transmit flag to 1
1007          ////    SFRPAGE = Global_SFRPAGE_SAVE;
1008          //      
1009          //      while(1)
1010          //      {
1011          //              while( Rcv_New == 0 );//Wait for new message
1012          //              Rcv_New = 0;
1013          //              
1014          //              if( *UART_Receive_Buffer_QueueHead++ != 'Z' )
1015          //              {
1016          //                      continue;
1017          //              }
1018          //              else
1019          //              {
1020          //                      while(1)
1021          //                      {
1022          //                              if(UART1_Receive_Buffer_Queue[0]==0x55)      
1023          //                              {  
1024          //                                      switch(UART1_Receive_Buffer_Queue [1])
1025          //                                      {
1026          //                                              case 0x51:
1027          //                                              a = (int)(UART1_Receive_Buffer_Queue [3]<<8| UART1_Receive_Buffer_Queue [2]);
1028          //                                              Temp = (int)(UART1_Receive_Buffer_Queue [9]<<8| UART1_Receive_Buffer_Queue [8]);
1029          //                                              a_flag = 1;
1030          //                                              break;
1031          //                                              case 0x52:
1032          //                                              w = (int)(UART1_Receive_Buffer_Queue [3]<<8| UART1_Receive_Buffer_Queue [2]);
1033          //                                              w_flag = 1;
1034          //                                              break;
1035          //                                              case 0x53:
1036          //                                              angle = (int)((unsigned int)UART1_Receive_Buffer_Queue [3]<<8| UART1_Receive_Buffer_Queue [2]);
1037          //                                              angle_flag = 1;
1038          //                                              break;
1039          //                                      } 
1040          //                              }
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 18  

1041          //                              
1042          //                              if( a_flag + w_flag + angle_flag == 3 )
1043          //                              {
1044          //                                      break;
1045          //                              }
1046          //                      }
1047          //                      
1048          //                      //Save the current state to ZeroPoint
1049          //                      ZeroPoint_a = a;
1050          //                      ZeroPoint_w = w;
1051          //                      ZeroPoint_angle = angle;
1052          //                      ZeroPoint_Temp = Temp;
1053          //                      //
1054          //                      SaveMapToFlash();
1055          //                      return;
1056          //              }
1057          
1058          //      }
1059          //}
1060          
1061          //----------------------------------------------------------------------------
1062          //----------------------------------------------------------------------------
1063          // balance_wheel
1064          //      Input:void
1065          //      Output:void
1066          //      check the whel
1067          //-----------------------------------------------------------------------------
1068          //      Delay_ms
1069          //-----------------------------------------------------------------------------
1070          //      input:count
1071          //      output:void
1072          //      make the Program wait for count ms
1073          //-----------------------------------------------------------------------------
1074          void Delay_ms(unsigned int count)
1075          {
1076   1              unsigned char ii,jj;
1077   1              for(ii=0;ii<count;ii++)
1078   1              {
1079   2                      for(jj=0;jj<250;jj++)
1080   2                              ;
1081   2              }
1082   1      }
1083          
1084          
1085          
1086          
1087          
1088          void Uart0_TransmitString(unsigned char * pucString , int iStringSize )
1089          {
1090   1              unsigned char *pucHeadofString = pucString;
1091   1      //      if( strlen(pucString) != iStringSize )
1092   1      //      {
1093   1      //              ERROR("Uart0_TransmitString():string lenth not match");
1094   1      //      }
1095   1              
1096   1      
1097   1              while( *pucHeadofString != 0 )
1098   1              {
1099   2                      Uart0_SendByte(*pucHeadofString);
1100   2                      ++pucHeadofString;
1101   2              }
1102   1              
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 19  

1103   1              
1104   1      }
*** WARNING C280 IN LINE 1088 OF FlashTestMain.c: 'iStringSize': unreferenced local variable
1105          
1106          void PWMChange(unsigned int side_ui, unsigned int PWM_degree)
1107          {
1108   1              char data SFRPAGE_SAVE =SFRPAGE;
1109   1              int i= 0;
1110   1              /*************************DEBUG BEGIN*************************/
1111   1              if( PWM_degree > 256 )
1112   1              {
1113   2                      ERROR("function PWMChange():PWM_degree is too large");
1114   2              }
1115   1      //      PWM_debug1 = (unsigned char)uiPWM1Degree;
1116   1      //      PWM_debug2 = (unsigned char)uiPWM2Degree << 4;
1117   1      //      PWM_debug3  = (unsigned char)uiPWM1Degree + (unsigned char)uiPWM2Degree << 4;
1118   1      //      PWM_debug4 = PWM_debug1 + PWM_debug2;
1119   1              //------------------------DEBUG END-------------------------------
1120   1              SFRPAGE = CONFIG_PAGE;
1121   1              P5 = PWM_degree;
1122   1              SFRPAGE = SFRPAGE_SAVE;
1123   1      
1124   1              if(side_ui == 1)
1125   1              {
1126   2                      PWM1CHANGEORDER =  0;
1127   2                      while( PWM1CHANGEORDER != 0 );//wait
1128   2                      PWM1CHANGEORDER =  1;
1129   2              }
1130   1              else if(side_ui == 2)
1131   1              {
1132   2                      PWM2CHANGEORDER =  0;
1133   2                      while( PWM2CHANGEORDER != 0 );//wait
1134   2                      PWM2CHANGEORDER =  1;
1135   2              }
1136   1      }
1137          void TouchKeepAlive(void)
1138          {
1139   1              char data SFRPAGE_SAVE =SFRPAGE;
1140   1              SFRPAGE=TIMER01_PAGE;
1141   1              KeepAliveTime_i = 0;
1142   1              ET0 = 1;//Enable Timer0 interrupt
1143   1              TR0 = 1;//Run Timer0
1144   1              SFRPAGE = SFRPAGE_SAVE;
1145   1      }
1146          void LostConnect(void)
1147          {
1148   1              uiPWM1Degree=uiPWM2Degree=0;
1149   1              PWMChange(1, 0);        
1150   1              PWMChange(2, 0);
1151   1              IN11=0;
1152   1              IN12=0;
1153   1              IN31=0;
1154   1              IN32=0;
1155   1      //      Uart0_TransmitString("lost connect",strlen("lost connect"));
1156   1      //      Acknowledge('s');
1157   1      }
1158          void Acknowledge(unsigned char back)
1159          {
1160   1      Uart0_SendByte(0x54);
1161   1              Uart0_SendByte(back);
1162   1              Uart0_SendByte(1);
1163   1              Uart0_SendByte(back+1);
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 20  

1164   1              
1165   1              
1166   1      }
1167          void balance_wheel(unsigned int *Counter_L_p, unsigned int *Counter_R_p, unsigned long *Counter_HighBits_a
             -)
1168          {
1169   1              char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
1170   1              static long CHG_Times = 0;
1171   1              static char last_order = 0;
1172   1              static unsigned int PWM1_degree = 0;
1173   1              static unsigned int PWM2_degree = 0;
1174   1              static unsigned int average_degree = 0;
1175   1              static char Enough_circle_to_balance = 0;
1176   1              double average_count_d = 0.0;
1177   1              if(car_state != 'f')
1178   1              {
1179   2                      if(car_state != last_order)
1180   2                      {
1181   3                              last_order = car_state;
1182   3                      }
1183   2                      return;
1184   2              }
1185   1              if(last_order != 'f')
1186   1              {
1187   2                      //This is the start of forwarding
1188   2                      last_order = 'f';
1189   2                      // Clear wheels' count
1190   2                      *Counter_L_p = 0;
1191   2                      *Counter_R_p = 0;
1192   2                      *Counter_HighBits_a = 0;
1193   2                      *(Counter_HighBits_a + 1) = 0;
1194   2                      Enough_circle_to_balance = 0;
1195   2                      CHG_Times = 0;
1196   2                      // Change the pwm
1197   2                      PWM1_degree = uiPWM1Degree * 64 -1;
1198   2                      PWM2_degree = uiPWM1Degree * 64 -1;
1199   2                      average_degree = (PWM1_degree + PWM2_degree) / 2.0;
1200   2                      PWMChange(1, PWM1_degree);      
1201   2                      PWMChange(2, PWM2_degree);
1202   2                      IN11=1;
1203   2                      IN12=0;
1204   2                      IN31=1;
1205   2                      IN32=0;
1206   2                      return;
1207   2              }
1208   1              else
1209   1              {
1210   2                      //check the counter
1211   2                      Check_Counter(Counter_L_p, Counter_R_p, Counter_HighBits_a);
1212   2                      if(Enough_circle_to_balance || ADJUST_THRESHOLD < *Counter_L_p || ADJUST_THRESHOLD < * Counter_R_p)
1213   2                      {
1214   3                              Enough_circle_to_balance = 1;
1215   3                              /*      
1216   3                                      1.Change The PWM every PWM_CHG_GAP count.
1217   3                                      2. proportional to wheel circle counts:PWM1 /PWM2 = dist1/dist2
1218   3                              */
1219   3                              if(*Counter_L_p / PWM_CHG_GAP > CHG_Times || *Counter_R_p / PWM_CHG_GAP > CHG_Times)
1220   3                              {
1221   4                                      CHG_Times = *Counter_L_p / PWM_CHG_GAP;
1222   4                                      average_count_d = *Counter_L_p /2.0 + *Counter_R_p / 2.0;
1223   4                                      PWM1_degree = *Counter_L_p / average_count_d * average_degree;
1224   4                                      PWM2_degree = *Counter_R_p / average_count_d * average_degree;
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 21  

1225   4                                      PWMChange(1, PWM1_degree);
1226   4                                      PWMChange(2, PWM2_degree);
1227   4                                      if(*Counter_L_p > 500 || *Counter_R_p > 500)
1228   4                                      {
1229   5                                              SFRPAGE = TMR4_PAGE;                // Set SFR page
1230   5                                              TMR4L = 0;
1231   5                                              TMR4H = 0;
1232   5                                              SFRPAGE = TMR3_PAGE;                // Set SFR page
1233   5                                              TMR3H = 0;
1234   5                                              TMR3L = 0;
1235   5                                              SFRPAGE = SFRPAGE_SAVE;
1236   5                                              *Counter_L_p = 0;
1237   5                                              *Counter_R_p = 0;
1238   5                                              *Counter_HighBits_a = 0;
1239   5                                              *(Counter_HighBits_a + 1) = 0;
1240   5                                              Enough_circle_to_balance = 0;
1241   5                                              CHG_Times = 0;
1242   5      
1243   5                                      }
1244   4                              }
1245   3                      }
1246   2                      return;
1247   2              }
1248   1      }
1249          
1250          void Check_Counter(unsigned int *Counter_L_p, unsigned int *Counter_R_p, unsigned long *Counter_HighBits_a
             -)
1251          {
1252   1      #ifndef CHECK_COUNTER_DEBUG
1253   1              static unsigned int c_L = 0;
1254   1              static unsigned int c_R = 0;
1255   1                                              char debug = 0;
1256   1      #endif
1257   1              char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
1258   1              SFRPAGE = TMR4_PAGE;                // Set SFR page
1259   1              *Counter_R_p = TMR4H;
1260   1              *Counter_R_p = *Counter_R_p << 8;
1261   1              *Counter_R_p += TMR4L;
1262   1              SFRPAGE = TMR3_PAGE;                // Set SFR page
1263   1              *Counter_L_p = TMR3H;
1264   1              *Counter_L_p = *Counter_L_p << 8;
1265   1              *Counter_L_p += TMR3L;
1266   1              
1267   1              if(*Counter_L_p >= 50000)
1268   1              {
1269   2                      TMR3H = 0;
1270   2                      TMR3L = 0;
1271   2                      *Counter_L_p = 0;
1272   2                      ++*(Counter_HighBits_a);
1273   2              }
1274   1              if(*Counter_R_p >= 50000)
1275   1              {
1276   2                      SFRPAGE = TMR4_PAGE;                // Set SFR page
1277   2                      TMR4H = 0;
1278   2                      TMR4L = 0;
1279   2                      *Counter_R_p = 0;
1280   2                      ++*(Counter_HighBits_a+1);
1281   2              }
1282   1              
1283   1      #ifndef CHECK_COUNTER_DEBUG
1284   1              if(*Counter_L_p > c_L )
1285   1              {
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 22  

1286   2                      c_L = *Counter_L_p;
1287   2              }
1288   1              if(*Counter_R_p > c_R )
1289   1              {
1290   2                      c_R = *Counter_R_p;
1291   2              }
1292   1              if(*Counter_R_p > 50)
1293   1              {
1294   2                      c_R = *Counter_R_p;
1295   2              }
1296   1      //      if( TMR3_1000_circles > 0 )
1297   1      //      {
1298   1      //              debug ++; 
1299   1      //      }
1300   1      #endif
1301   1              SFRPAGE = SFRPAGE_SAVE;
1302   1      }
1303          //-----------------------------------------------------------------------------
1304          // /INT0 ISR
1305          //-----------------------------------------------------------------------------
1306          //
1307          // Whenever a negative edge appears on P0.0, the LED is toggled.
1308          // The interrupt pending flag is automatically cleared by vectoring to the ISR
1309          //
1310          //-----------------------------------------------------------------------------
1311          void INT0_ISR (void) interrupt 0
1312          {
1313   1              char data SFRPAGE_SAVE =SFRPAGE;
1314   1              SFRPAGE = CONFIG_PAGE;
1315   1              Delay_ms(5);
1316   1              if(!P0^4)
1317   1              {
1318   2                      count_L ++;
1319   2              }
1320   1              SFRPAGE = SFRPAGE_SAVE;
1321   1      }
1322          
1323          //-----------------------------------------------------------------------------
1324          // /INT1 ISR
1325          //-----------------------------------------------------------------------------
1326          //
1327          // Whenever a negative edge appears on P0.1, the LED is toggled.
1328          // The interrupt pending flag is automatically cleared by vectoring to the ISR
1329          //
1330          //-----------------------------------------------------------------------------
1331          void INT1_ISR (void) interrupt 2
1332          {
1333   1              char data SFRPAGE_SAVE =SFRPAGE;
1334   1              SFRPAGE = CONFIG_PAGE;
1335   1              Delay_ms(5);
1336   1              if(!P0^5)
1337   1              {
1338   2                      count_R ++;
1339   2              }
1340   1              SFRPAGE = SFRPAGE_SAVE;
1341   1      }
1342          void Ext_Interrupt_Init (void)
1343          {
1344   1         char SFRPAGE_SAVE = SFRPAGE;
1345   1      
1346   1         SFRPAGE = TIMER01_PAGE;
1347   1      
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     11/29/2015 21:25:50 PAGE 23  

1348   1         TCON |= 0x05;                        // /INT 0 and /INT 1 are falling edge
1349   1                                             // triggered
1350   1      
1351   1         EX0 = 1;                            // Enable /INT0 interrupts
1352   1         EX1 = 1;                            // Enable /INT1 interrupts
1353   1      
1354   1         SFRPAGE = SFRPAGE_SAVE;
1355   1      }
1356          //-----------------------------------------------------------------------------
1357          // End Of File
1358          //-----------------------------------------------------------------------------
*** WARNING C294 IN LINE 485 OF FlashTestMain.c: unreachable code
*** WARNING C294 IN LINE 491 OF FlashTestMain.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3561    ----
   CONSTANT SIZE    =     59    ----
   XDATA SIZE       =    324      59
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  5 WARNING(S),  0 ERROR(S)
