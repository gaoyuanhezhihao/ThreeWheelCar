C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE FLASHTESTMAIN
OBJECT MODULE PLACED IN FlashTestMain.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE FlashTestMain.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //-----------------------------------------------------------------------------
   2          // F12x_UART0_Interrupt.c
   3          //-----------------------------------------------------------------------------
   4          // ????????????? RJ ?? ???????
   5          // ???????:     http://dadastudio.taobao.com/ 
   6          // ????????      C8051F12x-13x???.pdf ?? 21 ?:UART0
   7          //
   8          // Copyright 2006 Silicon Laboratories, Inc.
   9          // http://www.silabs.com
  10          //
  11          // Program Description:
  12          //
  13          // This program demonstrates how to configure the C8051F120 to write to and read 
  14          // from the UART interface. The program reads a word using the UART0 interrupts 
  15          // and outputs that word to the screen, with all characters in uppercase
  16          //
  17          // How To Test:
  18          //
  19          // 1) Download code to a 'F12x device that is connected to a UART transceiver
  20          // 2) Verify jumpers J6 and J9 are populated on the 'F12x TB.
  21          // 3) Connect serial cable from the transceiver to a PC
  22          // 4) On the PC, open HyperTerminal (or any other terminal program) and connect
  23          //    to the COM port at <BAUDRATE> and 8-N-1
  24          // 5) Download and execute code on an 'F12x target board.
  25          // 6) Type up to 64 characters into the Terminal and press Enter.  The MCU 
  26          //    will then print back the characters that were typed
  27          //   
  28          //
  29          // Target:         C8051F12x
  30          // Tool chain:     Keil C51 7.50 / Keil EVAL C51
  31          // Command Line:   None
  32          //
  33          // Release 1.0
  34          //    -Initial Revision (SM)
  35          //    -11 JULY 2007
  36          //
  37          //       P5.0-->PWMHigelevel bit0
  38          //       P5.1-->PWMHigelevel bit1
  39          //       P5.2-->PWMHigelevel bit2
  40          //       P5.3-->PWMHigelevel bit3
  41          //   P5.4-->PWMHigelevel bit4
  42          //       P5.5-->PWMHigelevel bit5
  43          //   P5.6-->PWMHigelevel bit6
  44          //       P5.7-->PWMHigelevel bit7
  45          //       P4.6-->PWMHigelevel bit8
  46          //       P4.7-->PWMHigelevel bit9
  47          //       P4.0-->cPWM1ChangeOrder
  48          //   P4.1-->cPWM2ChangeOrder
  49          
  50          //-----------------------------------------------------------------------------
  51          // Includes
  52          //-----------------------------------------------------------------------------
  53          
  54          #include <c8051f120.h>                 // SFR declarations
  55          #include <stdio.h>                     
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 2   

  56          #include <string.h>
  57          #include <F120_FlashPrimitives.h>
  58          #include <math.h>
  59          #include "MyDebug.h"
  60          //-----------------------------------------------------------------------------
  61          // 16-bit SFR Definitions for 'F12x
  62          //-----------------------------------------------------------------------------
  63          
  64          sfr16 RCAP2    = 0xca;                 // Timer2 capture/reload
  65          sfr16 TMR2     = 0xcc;                 // Timer2
  66          
  67          //-----------------------------------------------------------------------------
  68          // Global Constants
  69          //-----------------------------------------------------------------------------
  70          
  71          #define BAUDRATE     9600            // Baud rate of UART in bps
  72          #define UART1BAUDRATE 115200             
  73          #define Const_Control_Time      10                      //ADC cycle = Const_Control_Time*Timer0 cycle = 10*10ms=100ms
  74          sbit PWM1       =       P3^2;                      
  75          sbit IN11               =       P6^3;
  76          sbit IN12               =       P6^4;
  77          sbit TMR3Debug  =   P3^5;
  78          sbit SET                =       P3^1;
  79          sbit Key1               =       P7^2;
  80          sbit PWM3               =       P6^7;
  81          sbit IN31               =       P6^5;
  82          sbit IN32               =       P6^6;
  83          sbit DEBUGPORT  =   P3^0;
  84          sbit PWM1CHANGEORDER = P4^0;
  85          sbit PWM2CHANGEORDER = P4^1;
  86          sbit PWMDEGREE_HighBit0=P4^6;
  87          sbit PWMDEGREE_HighBit1=P4^7;
  88          sbit D0 = P5^0;
  89          sbit D1 = P5^1;
  90          sbit D2 = P5^2;
  91          sbit D3 = P5^3;
  92          sbit D4 = P5^4;
  93          sbit D5 = P5^5;
  94          sbit D6 = P5^6;
  95          sbit D7 = P5^7;
  96          sbit L_UP = P0^6;
  97          sbit R_UP = P0^7;
  98          sbit START_BALANCe = P0^5;
  99          // SYSTEMCLOCK = System clock frequency in Hz
 100          #define SYSTEMCLOCK       (22118400L * 9 / 4)
 101          #define TIMER0CLOCK                     (SYSTEMCLOCK/48)
 102          #define TIMER1CLOCK             (SYSTEMCLOCK/48)
 103          #define TIMER3CLOCK                     (SYSTEMCLOCK/48)
 104          #define MAP_ADC_ANGEL_SIZE  13
 105          #define UART_BUFFERSIZE 64
 106          #define UART1_BUFFERSIZE 22
 107          #define PWMDEGREE_Low8Bits P5
 108          
 109          //--------------------------------POSE & Control-------------------------------------------
 110          #define MAX_PWM 800
 111          #define ANGELRANGE_SIZE 7
 112          #define ANGELSCALE_10 0xF8E3  //-10
 113          #define ANGELSCALE_5 0xFC71  //-5
 114          #define ANGELSCALE_3 0xFDDD  //-3
 115          #define ANGELSCALE0  0x0000  //0
 116          #define ANGELSCALE3  0x0222  //3
 117          #define ANGELSCALE5  0x038E  //5
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 3   

 118          #define ANGELSCALE10  0x071C  //10
 119          
 120          #define ADJUST_THRESHOLD 100
 121          #define PWM_CHG_GAP 50
 122          //-----------------------------------------------------------------------------
 123          // Function Prototypes
 124          //-----------------------------------------------------------------------------
 125          void Acknowledge_54(unsigned char index, unsigned char flag, unsigned char error);
 126          void OSCILLATOR_Init (void);         
 127          void PORT_Init (void);
 128          void UART0_Init (void);
 129          void RerangeTheBufferQueue(unsigned char IndexOfBuffer);
 130          void WirelessModule_Init(void);
 131          void Uart0_SendByte(unsigned char value);
 132          void Uart0_TransmitString(unsigned char * pucString , int iStringSize );
 133          void TIMER0_Init(void);
 134          void TIMER1_Init(unsigned int count);
 135          void Calibration(void);
 136          void Delay_ms(unsigned int count);
 137          void Regulate(void);
 138          void FLASH_ByteWrite (FLADDR addr, char byte, bit SFLE);
 139          unsigned char FLASH_ByteRead (FLADDR addr, bit SFLE);
 140          void FLASH_PageErase (FLADDR addr, bit SFLE);
 141          void SaveMapToFlash(void);
 142          void RestoreMapFromFlash(void);
 143          void Timer3_Init(void);
 144          void Timer4_Init(void);
 145          void UART1_Init (void);
 146          void Uart1_SendByte(unsigned char value);
 147          void PWMChange(unsigned int side_ui, unsigned int PWM_degree);
 148          void TouchKeepAlive(void);
 149          void Acknowledge(unsigned char back);
 150          void LostConnect(void);
 151          void Check_Counter(unsigned int *Counter_L_p, unsigned int *Counter_R_p, unsigned long *Counter_HighBits_a
             -);
 152          void balance_wheel(void);
 153          void process_msg_53(void);
 154          void process_msg_54(void);
 155          void process_msg_55(void);
 156          void Ext_Interrupt_Init (void);
 157          void Report_PWM_55(void);
 158          //-----------------------------------------------------------------------------
 159          // Global Variables
 160          //-----------------------------------------------------------------------------
 161          
 162          //-------------------------------UART0-----------------------------------------
 163          unsigned int UART0_Receive_Buffer_Size = 0;
 164          unsigned char UART_Receive_Buffer_Queue[UART_BUFFERSIZE]={0};
 165          unsigned char * UART_Receive_Buffer_QueueHead=UART_Receive_Buffer_Queue;
 166          unsigned char * UART_Receive_Buffer_QueueBottom=UART_Receive_Buffer_Queue;
 167          unsigned char UART_Transmit_Buffer_Queue[UART_BUFFERSIZE];
 168          unsigned char * UART_Transmit_Buffer_QueueHead=UART_Transmit_Buffer_Queue;
 169          unsigned char * UART_Transmit_Buffer_QueueBottom=UART_Transmit_Buffer_Queue;
 170          unsigned char TX_Ready =1;
 171          static   char Byte;
 172                           char Rcv_New=0;
 173          //--------------------------------UART1-----------------------------------------
 174          unsigned char   Counter_UART1 = 0;
 175          unsigned char   Flag_NewFrame = 0;
 176          unsigned char   UART1_Receive_Buffer_Queue[UART1_BUFFERSIZE]={0};
 177          unsigned char * UART1_Receive_Buffer_QueueHead   = UART1_Receive_Buffer_Queue;
 178          unsigned char * UART1_Receive_Buffer_QueueBottom  = UART1_Receive_Buffer_Queue;
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 4   

 179          
 180          
 181          //--------------------------------POSE & Control-------------------------------------------
 182          int a,angle,Temp,w;
 183          int ZeroPoint_a,ZeroPoint_w,ZeroPoint_angle,ZeroPoint_Temp;
 184          int iDeviation = 0;
 185          unsigned int uiAbsoluteDeviation =  0;
 186          unsigned int AbsoluteW_ui = 0;
 187          int iStablePoint = 0;
 188          bit RotateDirection = 0;
 189          
 190          int iAngleRange[] = 0;
 191          struct Pair_Angel_Control{
 192                  int Angel;
 193                  int Kp;
 194                  int Ki;
 195                  int Kd;
 196          };
 197          struct Pair_Angel_Control Map_Angel_PID[ANGELRANGE_SIZE] = {{ANGELSCALE_10,5,0,1},\
 198                                                                                                                                          {ANGELSCALE_5,4,0,1},\
 199                                                                                                                                          {ANGELSCALE_3,3,0,1},\
 200                                                                                                                                          {ANGELSCALE0,1,0,1},\
 201                                                                                                                                          {ANGELSCALE3,2,0,1},\
 202                                                                                                                                          {ANGELSCALE5,3,0,1},\
 203                                                                                                                                          {ANGELSCALE10,5,0,1}};
 204          int iCurrentKey = 0;
 205          unsigned int KeepAliveTime_i=0;
 206          char car_state = 0;  //1 = it is go forwarding state now
 207          unsigned int PWM_L_ui = 0;
 208          unsigned int PWM_R_ui = 0;      
 209          int PWM_L_add = 0;
 210          int PWM_R_add = 0;                                                                                                                              
 211          char global_balance_flag = 0;                                                                                                                   
 212          //-------------------------------Motor--------------------------------
 213          unsigned int Motor1_Time=0;
 214          unsigned int Motor2_Time=0;
 215          
 216          unsigned int PWM1_HighLevelCount=0;
 217          unsigned int PWM1_LowLevelCount=0;
 218          float fPWM1_HighLevelPercent = 0.5f;
 219          bit pwm1_flag=0;
 220          
 221          unsigned int PWM3_HighLevelCount=0;
 222          unsigned int PWM3_LowLevelCount=0;
 223          float fPWM3_HighLevelPercent = 0.9f;
 224          bit pwm3_flag=0;
 225          
 226          unsigned char TH1_HighLevelPrefetch = 0;
 227          unsigned char TL1_HighLevelPrefetch = 0;
 228          unsigned char TMRH3_HighLevelPrefetch = 0;
 229          unsigned char TMRL3_HighLevelPrefetch = 0;
 230          
 231          unsigned char TH1_LowLevelPrefetch = 0;
 232          unsigned char TL1_LowLevelPrefetch = 0;
 233          unsigned char TMRH3_LowLevelPrefetch = 0;
 234          unsigned char TMRL3_LowLevelPrefetch = 0;
 235          
 236          unsigned int uiPWM1Degree=0;
 237          unsigned int uiPWM2Degree=0;
 238          bit     PWM1ChangeOrder = 0;
 239          bit     PWM2ChangeOrder = 0;
 240          
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 5   

 241          char cOldRotateDirection = 0;
 242          //-------------------------------System--------------------------------
 243          char data Global_SFRPAGE_SAVE;
 244          //unsigned int i=0;
 245          char cDebugTmp=0;
 246          char Control_TimeIsUp = 0;
 247          unsigned char Control_Time=0;
 248          
 249          
 250          unsigned char TH0_Prefetch = 0;
 251          unsigned char TL0_Prefetch = 0;
 252          unsigned char PWM_debug1 = 0;
 253          unsigned char PWM_debug2 = 0;
 254          unsigned char PWM_debug3 = 0;
 255          unsigned char PWM_debug4 = 0;
 256          //unsigned int TMR3_1000_circles = 0;
 257          //unsigned int TMR4_1000_circles = 0;
 258          
 259          //-----------------------------------------------------------------------------
 260          // main() Routine
 261          //-----------------------------------------------------------------------------
 262          
 263          void main (void)
 264          {
 265   1              unsigned int Counter_L =0;
 266   1              unsigned int *Counter_L_p = &Counter_L;
 267   1              unsigned int Counter_R = 0;
 268   1              unsigned int *Counter_R_p = &Counter_R;
 269   1              unsigned long Counter_HighBits_a[2] = {0,0};
 270   1              //Initialization
 271   1              SFRPAGE = CONFIG_PAGE;
 272   1              WDTCN = 0xDE;                       // Disable watchdog timer
 273   1              WDTCN = 0xAD;
 274   1              OSCILLATOR_Init();  
 275   1              PORT_Init();                       // Initialize crossbar and GPIO
 276   1              UART0_Init();                      // Initialize UART0
 277   1      //      UART1_Init();
 278   1              WirelessModule_Init();
 279   1              TIMER0_Init();
 280   1              Ext_Interrupt_Init();
 281   1      //      Timer4_Init();
 282   1      //      Timer3_Init();
 283   1              EA = 1;
 284   1      
 285   1              //*************flash test**********************
 286   1      //      FLASH_PageErase(0x8000,1);
 287   1      //      for(i=0;i<MAP_ADC_ANGEL_SIZE;i++)
 288   1      //      {
 289   1      //              Map_ADC_Angel_array[i].ADC = i;
 290   1      //              Map_ADC_Angel_array[i].Angel = -i;
 291   1      //      }
 292   1      //      SaveMapToFlash();
 293   1      //      FLASH_PageErase(0x8000,1);
 294   1      //      FLASH_ByteWrite(0x8000,'j',1);
 295   1      //      FLASH_ByteWrite(0x8001,'a',1);
 296   1      //      cReadFlash = FLASH_ByteRead(0x8000,1);
 297   1      ////*******************PWM test******************
 298   1      //      uiPWM1Degree = 0;
 299   1      //      while(1)
 300   1      //      {
 301   1      //              uiPWM1Degree +=50;
 302   1      //              PWMChange(1);
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 6   

 303   1      //              PWMChange(2);
 304   1      //      }
 305   1      ////-------------------PWM test------------------
 306   1              
 307   1              
 308   1      
 309   1      
 310   1              Uart0_TransmitString("Ready",strlen("Ready"));
 311   1              while (1)
 312   1              {
 313   2      //              /******Debug********/
 314   2      //              PWMChange();
 315   2      //              /******End**********/
 316   2                      
 317   2                      //if more than 20*50ms=1000ms is past since last message.
 318   2                      if(KeepAliveTime_i > 100)
 319   2                      {
 320   3                              LostConnect();
 321   3                              if(UART_Receive_Buffer_QueueHead < UART_Receive_Buffer_QueueBottom)
 322   3                              {
 323   4                                      TouchKeepAlive();
 324   4                              }       
 325   3                      }
 326   2                      if(UART_Receive_Buffer_QueueHead < UART_Receive_Buffer_QueueBottom)
 327   2                      {
 328   3                              //Uart0_SendByte(*UART_Receive_Buffer_Queue);
 329   3                              //++UART_Receive_Buffer_Queue;
 330   3                      
 331   3                              // Switch by the message head
 332   3                              switch(*UART_Receive_Buffer_QueueHead)
 333   3                              {
 334   4                                      case 0x53:
 335   4                                              process_msg_53();
 336   4                                              break;
 337   4                                      case 0x54:
 338   4                                              process_msg_54();
 339   4                                              break;
 340   4                                      case 0x55:
 341   4                                              process_msg_55();
 342   4                                              break;
 343   4                                      default:
 344   4                                              ++UART_Receive_Buffer_QueueHead;//throw this byte
 345   4                                              break;
 346   4                              }       
 347   3                              
 348   3                      }       
 349   2                      // Get the counter information
 350   2      //              Check_Counter(Counter_L_p, Counter_R_p, Counter_HighBits_a);
 351   2      //              balance_wheel();
 352   2              }
 353   1      }
 354          
 355          //-----------------------------------------------------------------------------
 356          // Initialization Subroutines
 357          //-----------------------------------------------------------------------------
 358          
 359          //-----------------------------------------------------------------------------
 360          // OSCILLATOR_Init
 361          //-----------------------------------------------------------------------------
 362          //
 363          // Return Value : None
 364          // Parameters   : None
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 7   

 365          //
 366          // This function initializes the system clock to use the PLL as its clock
 367          // source, where the PLL multiplies the external 22.1184MHz crystal by 9/4.
 368          //
 369          //-----------------------------------------------------------------------------
 370          void OSCILLATOR_Init (void)
 371          {
 372   1         int i=0;                              // Software timer
 373   1      
 374   1         char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 375   1      
 376   1         SFRPAGE = CONFIG_PAGE;              // Set SFR page
 377   1      
 378   1         OSCICN = 0x80;                      // Set internal oscillator to run
 379   1                                             // at its slowest frequency
 380   1      
 381   1         CLKSEL = 0x00;                      // Select the internal osc. as
 382   1                                             // the SYSTEMCLOCK source
 383   1      
 384   1         // Initialize external crystal oscillator to use 22.1184 MHz crystal
 385   1      
 386   1         OSCXCN = 0x67;                      // Enable external crystal osc.
 387   1          for(i=0; i < 256; ) // Wait at least 1ms
 388   1              {
 389   2                      i++;
 390   2              }
 391   1         while (!(OSCXCN & 0x80));           // Wait for crystal osc to settle
 392   1      
 393   1         SFRPAGE = LEGACY_PAGE;
 394   1         FLSCL |=  0x30;                     // Initially set FLASH read timing for
 395   1                                             // 100MHz SYSTEMCLOCK (most conservative
 396   1                                             // setting)
 397   1         if (SYSTEMCLOCK <= 25000000L) {           
 398   2         // Set FLASH read timing for <=25MHz
 399   2            FLSCL &= ~0x30;
 400   2         } else if (SYSTEMCLOCK <= 50000000L) {    
 401   2         // Set FLASH read timing for <=50MHz
 402   2            FLSCL &= ~0x20;
 403   2         } else if (SYSTEMCLOCK <= 75000000L) {    
 404   2         // Set FLASH read timing for <=75MHz
 405   2            FLSCL &= ~0x10;
 406   2         } else {                            // set FLASH read timing for <=100MHz
 407   2            FLSCL &= ~0x00;
 408   2         }
 409   1      
 410   1         // Start PLL for 50MHz operation
 411   1         SFRPAGE = PLL0_PAGE;
 412   1         PLL0CN = 0x04;                      // Select EXTOSC as clk source
 413   1         PLL0CN |= 0x01;                     // Enable PLL power
 414   1         PLL0DIV = 0x04;                     // Divide by 4
 415   1         PLL0FLT &= ~0x0f;
 416   1         PLL0FLT |=  0x0f;                   // Set Loop Filt for (22/4)MHz input clock
 417   1         PLL0FLT &= ~0x30;                   // Set ICO for 30-60MHz
 418   1         PLL0FLT |=  0x10;
 419   1      
 420   1         PLL0MUL = 0x09;                     // Multiply by 9
 421   1      
 422   1         // wait at least 5us
 423   1         for (i = 0; i < 256; )
 424   1         {
 425   2                 i++;
 426   2         }
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 8   

 427   1      
 428   1         PLL0CN |= 0x02;                     // Enable PLL
 429   1      
 430   1         while (PLL0CN & 0x10 == 0x00);      // Wait for PLL to lock
 431   1      
 432   1         SFRPAGE = CONFIG_PAGE;
 433   1      
 434   1         CLKSEL = 0x02;                      // Select PLL as SYSTEMCLOCK source
 435   1      
 436   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFRPAGE
 437   1      }
 438          
 439          //-----------------------------------------------------------------------------
 440          // PORT_Init
 441          //-----------------------------------------------------------------------------
 442          //
 443          // Return Value : None
 444          // Parameters   : None
 445          //
 446          // This function configures the crossbar and GPIO ports.
 447          //
 448          // P0.0   digital   push-pull     UART TX
 449          // P0.1   digital   open-drain    UART RX
 450          //-----------------------------------------------------------------------------
 451          void PORT_Init (void)
 452          {
 453   1              char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 454   1      
 455   1              SFRPAGE = CONFIG_PAGE;              // Set SFR page
 456   1      
 457   1              XBR0     = 0x04;                    // Enable UART0
 458   1      //      XBR0    |= 0x08;                     // Route CEX0 to P0.2
 459   1              XBR1     = 0x04 + 0x10;                         //Enable /INT0 and /INT1
 460   1      //      XBR1     = 0x20;                                        //Enable T2
 461   1              XBR2     = 0x40;                    // Enable crossbar and weak pull-up
 462   1      //      XBR2    |= 0X08;                                        //Enable T4
 463   1      //      XBR2    |= 0x04;                                        //Enable UART1
 464   1       //   P1MDIN   = 0xFF;                                   
 465   1              P0MDOUT |= 0x04;                    // Set CEX0 (P0.2) to push-pull
 466   1              P0MDOUT |= 0x01;                    // Set TX pin to push-pull
 467   1              P0MDOUT |= 0x04;                                        //Set UART1 TX pin to push-pull
 468   1      
 469   1              P3MDOUT = 0x18;                                         // P3.3 P3.4 is  push-pull
 470   1      //      P6MDOUT = 0x60;                                         // P6.x is push-pull
 471   1              P6              &= ~0x80;
 472   1              P6MDOUT = 0xFF;
 473   1              P5MDOUT = 0xFF;                                         //P6 is push-pull
 474   1              P4MDOUT = 0xC3;                                         //P4.7,4.6,4.0,4.1 is push-pull
 475   1      //      P7MDOUT = 0x00;                                         //P7.x is  open-drain
 476   1              SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 477   1      }
 478          
 479          //-----------------------------------------------------------------------------
 480          // TIMER0_Init
 481          //-----------------------------------------------------------------------------
 482          //
 483          //
 484          //-----------------------------------------------------------------------------
 485          void TIMER0_Init(void)
 486          {
 487   1      
 488   1              char data SFRPAGE_SAVE =SFRPAGE;
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 9   

 489   1              SFRPAGE=TIMER01_PAGE;
 490   1              TCON &= ~0x30;//stop the timer0
 491   1              TMOD &= ~0x00;//Set the timer0 work in mode of hex
 492   1              TMOD |= 0x01;
 493   1              CKCON &= 0xf0;
 494   1              CKCON |= 0x02;
 495   1              CKCON &= ~0x08;//Timer 0 uses the clock defined by the prescale bits
 496   1              TR0 = 0;
 497   1              TH0= (0xFFFF-TIMER0CLOCK/20)>>8; //Timer0 cycle = 50ms
 498   1              TL0=  0xFFFF-TIMER0CLOCK/20;
 499   1              ET0 = 1;//Enable interrupt
 500   1              TR0 = 1;//Run Timer0
 501   1              SFRPAGE = SFRPAGE_SAVE;
 502   1      }
 503          
 504          //-----------------------------------------------------------------------------
 505          // TIMER1_Init
 506          //-----------------------------------------------------------------------------
 507          //
 508          // Return Value : None
 509          // Parameters   :
 510          //   1)  int counts - calculated Timer overflow rate
 511          //                    range is postive range of integer: 0 to 32767
 512          //
 513          // Configure Timer1 to auto-reload at interval specified by <counts> (no
 514          // interrupt generated) using SYSCLK as its time base.
 515          //
 516          //-----------------------------------------------------------------------------
 517          //void TIMER1_Init(unsigned int count)
 518          //{
 519          //      char data SFRPAGE_SAVE =SFRPAGE;
 520          //      PWM1_HighLevelCount = count * fPWM1_HighLevelPercent;
 521          //      PWM1_LowLevelCount = (float)count * (1-fPWM1_HighLevelPercent);
 522          //      SFRPAGE=TIMER01_PAGE;
 523          //      TCON &= ~0xC0;//stop the timer1
 524          //      TMOD &= ~0x00;//Set the timer1 work in mode of hex
 525          //      TMOD |= 0x10;
 526          //      
 527          //      CKCON &=0x0f;//clear CKCON bit4~7
 528          //      CKCON |= 0x10;//Timer 1 use SYSTEMCLOCK
 529          //      
 530          //      TH1_HighLevelPrefetch = ( 0xffff - (unsigned int) (count * fPWM1_HighLevelPercent) )>>8;
 531          //      TL1_HighLevelPrefetch =   0xffff - (unsigned int) (count * fPWM1_HighLevelPercent) ;
 532          //      TH1_LowLevelPrefetch = (  0xffff - (unsigned int )( count * (1-fPWM1_HighLevelPercent) )  )>>8;
 533          //      TL1_LowLevelPrefetch =    0xffff - (unsigned int) (count * (1-fPWM1_HighLevelPercent));
 534          //      ET1 = 1;//Enable interrupt;
 535          //      TCON |= 0xC0;//start the timer1
 536          //      
 537          //      SFRPAGE = SFRPAGE_SAVE;
 538          //}
 539          
 540          //-----------------------------------------------------------------------------
 541          // TIMER3_Init
 542          //-----------------------------------------------------------------------------
 543          void Timer3_Init(void)
 544          {
 545   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 546   1      
 547   1              SFRPAGE = TMR3_PAGE;                // Set SFR page
 548   1              TMR3CF  = 0x00;
 549   1              TMR3CN  = 0x00;
 550   1              TMR3CN  = 0x02;                                         //Counter mode
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 10  

 551   1      //      tmp=TMR3CN;
 552   1      //      TMR3CF &= ~0x18;                    // Timer3 uses SYSCLK/12
 553   1              TMR3L = 0x00;                       // Init the Timer3 register
 554   1              TMR3H = 0x00;
 555   1              TMR3CN |= 0x04;                      // Enable Counter3
 556   1      //      ET4 = 1;                            // Timer4 interrupt enabled
 557   1              TR3 = 1;
 558   1              
 559   1              SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 560   1      }
 561          void Timer4_Init(void)
 562          {
 563   1          char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
 564   1      
 565   1              SFRPAGE = TMR4_PAGE;                // Set SFR page
 566   1              TMR4CF  = 0x00;
 567   1              TMR4CN  = 0x00;
 568   1              TMR4CN  = 0x02;                                         //Counter mode
 569   1      //      tmp=TMR4CN;
 570   1              TMR4L = 0x00;                      
 571   1              TMR4H = 0x00;
 572   1              TMR4CN |= 0x04;                      // Enable Counter4
 573   1      //      ET4 = 1;                            // Timer4 interrupt enabled
 574   1              TR4 = 1;
 575   1              
 576   1              SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 577   1      }
 578          //void Timer3_ISR(void) interrupt 14
 579          //{
 580          //      char data SFRPAGE_SAVE =SFRPAGE;//Save current SFP page
 581          //      SFRPAGE = TMR3_PAGE;
 582          //      TMR3Debug = ~TMR3Debug;
 583          
 584          //      
 585          //      if( Control_Time == 0 )
 586          //      {
 587          //              Control_Time = Const_Control_Time;
 588          //              Control_TimeIsUp=1;
 589          ////            /***************Debug Begin***********************/
 590          ////            IN31 ^= 1;
 591          ////            //---------------Debug End ---------------------------
 592          //      }
 593          //      else
 594          //      {
 595          //              Control_Time--;
 596          //      }
 597          //      TMR3CN &= ~0x80;//clear interrupt flag
 598          //      SFRPAGE=Global_SFRPAGE_SAVE;
 599          //      SFRPAGE = SFRPAGE_SAVE;
 600          //}
 601          
 602          //-----------------------------------------------------------------------------
 603          // UART0_Init   Variable baud rate, Timer 2, 8-N-1
 604          //-----------------------------------------------------------------------------
 605          //
 606          // Return Value : None
 607          // Parameters   : None
 608          //
 609          // Configure UART0 for operation at <baudrate> 8-N-1 using Timer2 as
 610          // baud rate source.
 611          //
 612          //-----------------------------------------------------------------------------
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 11  

 613          void UART0_Init (void)
 614          {
 615   1         char SFRPAGE_SAVE;
 616   1      
 617   1         SFRPAGE_SAVE = SFRPAGE;             // Preserve SFRPAGE
 618   1      
 619   1         SFRPAGE = TMR2_PAGE;
 620   1      
 621   1         TMR2CN = 0x00;                      // Timer in 16-bit auto-reload up timer
 622   1                                             // mode
 623   1         TMR2CF = 0x08;                      // SYSCLK is time base; no output;
 624   1                                             // up count only
 625   1         RCAP2 = - ((long) SYSTEMCLOCK/BAUDRATE/16);
 626   1         TMR2 = RCAP2;
 627   1         TR2= 1;                             // Start Timer2
 628   1      
 629   1         SFRPAGE = UART0_PAGE;
 630   1      
 631   1         SCON0 = 0x50;                       // 8-bit variable baud rate;
 632   1                                             // 9th bit ignored; RX enabled
 633   1                                             // clear all flags
 634   1         SSTA0 = 0x15;                       // Clear all flags; enable baud rate
 635   1                                             // doubler (not relevant for these
 636   1                                             // timers);
 637   1                                             // Use Timer2 as RX and TX baud rate
 638   1                                             // source;
 639   1         ES0 = 1;  
 640   1         IP |= 0x10;
 641   1      
 642   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFRPAGE
 643   1      }
 644          
 645          
 646          //-----------------------------------------------------------------------------
 647          // Interrupt Service Routines
 648          //-----------------------------------------------------------------------------
 649          
 650          //-----------------------------------------------------------------------------
 651          // Timer0_ISR
 652          //-----------------------------------------------------------------------------
 653          //
 654          //
 655          //-----------------------------------------------------------------------------
 656          void Timer0_ISR(void) interrupt 1
 657          {       
 658   1              Global_SFRPAGE_SAVE=SFRPAGE;//Save current SFP page
 659   1              SFRPAGE=CONFIG_PAGE;
 660   1              KeepAliveTime_i++;
 661   1              
 662   1              TF0=0;
 663   1              SFRPAGE=Global_SFRPAGE_SAVE;
 664   1      }
 665          //-----------------------------------------------------------------------------
 666          // Timer1_ISR
 667          //-----------------------------------------------------------------------------
 668          //
 669          //
 670          //-----------------------------------------------------------------------------
 671          //void Timer1_ISR(void) interrupt 3
 672          //{
 673          //      char data SFRPAGE_SAVE =SFRPAGE;//Save current SFP page
 674          //      if(!pwm1_flag)
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 12  

 675          //      {
 676          //                      
 677          //              //Start of High level
 678          //                      pwm1_flag = 1;  //Set flag
 679          //                      SFRPAGE=CONFIG_PAGE;
 680          //                      PWM1 = 1;       //Set PWM o/p pin
 681          //                      
 682          //                      TH1 = TH1_HighLevelPrefetch;    //Load timer
 683          //                      TL1 = TL1_HighLevelPrefetch;
 684          //                      TF0 = 0;                //Clear interrupt flag
 685          //                      SFRPAGE=SFRPAGE_SAVE;
 686          //                      return;         //Return
 687          //      }
 688          //      else
 689          //      {       //Start of Low level
 690          //              pwm1_flag = 0;  //Clear flag
 691          //              SFRPAGE=CONFIG_PAGE;
 692          //              PWM1 = 0;       //Clear PWM o/p pin
 693          //              
 694          //              TH1 = TH1_LowLevelPrefetch;     //Load timer
 695          //              TL1 = TL1_LowLevelPrefetch;
 696          //              TF0 = 0;        //Clear Interrupt flag
 697          //              
 698          //              SFRPAGE=SFRPAGE_SAVE;
 699          //              return;         //return
 700          //      }
 701          //}
 702          
 703          //void Timer3_ISR(void) interrupt 14
 704          //{
 705          //      char data SFRPAGE_SAVE =SFRPAGE;//Save current SFP page
 706          //      if(!pwm3_flag)
 707          //      {
 708          //                      
 709          //              //Start of High level
 710          //                      pwm3_flag = 1;  //Set flag
 711          //                      SFRPAGE = CONFIG_PAGE;
 712          //                      PWM3 = 1;       //Set PWM o/p pin
 713          //              
 714          //                      SFRPAGE = TMR3_PAGE;
 715          //                      TMR3H = TMRH3_HighLevelPrefetch;        //Load timer
 716          //                      TMR3L = TMRL3_HighLevelPrefetch;
 717          //                                              
 718          //                      TF3 = 0;                //Clear interrupt flag
 719          //              
 720          //                      SFRPAGE = SFRPAGE_SAVE;
 721          //                      return;
 722          //      }
 723          //      else
 724          //      {       //Start of Low level
 725          //              pwm3_flag = 0;  //Clear flag
 726          //              
 727          //              SFRPAGE = CONFIG_PAGE;
 728          //              PWM3 = 0;       //Set PWM o/p pin
 729          //              
 730          //              SFRPAGE = TMR3_PAGE;
 731          //              TMR3H = TMRH3_LowLevelPrefetch; //Load timer
 732          //              TMR3L = TMRL3_LowLevelPrefetch;
 733          //              
 734          //              
 735          //              TF3 = 0;        //Clear Interrupt flag
 736          //              
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 13  

 737          //              SFRPAGE = SFRPAGE_SAVE;
 738          //              return; 
 739          //      }
 740          //}
 741          //-----------------------------------------------------------------------------
 742          // UART0_Interrupt
 743          //-----------------------------------------------------------------------------
 744          //
 745          // This routine is invoked whenever a character is entered or displayed on the
 746          // Hyperterminal.
 747          //
 748          //-----------------------------------------------------------------------------
 749          
 750          void UART0_Interrupt (void) interrupt 4
 751          {
 752   1         SFRPAGE = UART0_PAGE;
 753   1      
 754   1         if ( RI0 == 1 ) //if the buffer is not full
 755   1         {
 756   2            
 757   2                      Byte = SBUF0;                      // Read a character from UART
 758   2                      //if the buffer is't full
 759   2                  if(  (UART_Receive_Buffer_QueueBottom-UART_Receive_Buffer_QueueHead) < UART_BUFFERSIZE )
 760   2                  {
 761   3                          if ( UART_Receive_Buffer_QueueBottom < (UART_Receive_Buffer_Queue+UART_BUFFERSIZE) )
 762   3                              {
 763   4                                      *UART_Receive_Buffer_QueueBottom = Byte; // Store in array
 764   4                                      UART_Receive_Buffer_QueueBottom++;
 765   4                                      if( UART_Receive_Buffer_QueueBottom >= (UART_Receive_Buffer_Queue+UART_BUFFERSIZE) )
 766   4                                              RerangeTheBufferQueue('r');
 767   4                                      Rcv_New=1;//Notice new message come
 768   4                                      UART0_Receive_Buffer_Size++;
 769   4                              }
 770   3                              else
 771   3                                      RerangeTheBufferQueue('r');
 772   3                  }
 773   2                  RI0 = 0;                           // Clear interrupt flag
 774   2         }
 775   1      
 776   1         if (TI0 == 1)                   // Check if transmit flag is set
 777   1         {
 778   2                 TX_Ready = 1;
 779   2                 TI0 = 0;
 780   2      //      if ( UART_Transmit_Buffer_QueueHead < UART_Transmit_Buffer_QueueBottom )         // If buffer not 
             -empty
 781   2      //      {
 782   2      ////         Byte = UART_Buffer[UART_Output_First];
 783   2      ////         if ((Byte >= 0x61) && (Byte <= 0x7A)) { // If upper case letter
 784   2      ////            Byte -= 32; }
 785   2      ////                                    int count = UART_Transmit_Buffer_QueueBottom - UART_Transmit_Buffer_QueueHead;
 786   2      ////                                    for(;count>0;count--)
 787   2      ////                                    {
 788   2      ////                                            Uart0_SendByte(*UART_Transmit_Buffer_QueueHead);  // Transmit to Hyperterminal
 789   2      ////                                        UART_Transmit_Buffer_QueueHead++;
 790   2      ////                                    }
 791   2      ////              while( UART_Transmit_Buffer_QueueHead < UART_Transmit_Buffer_QueueBottom )
 792   2      ////              {
 793   2      //                        TI0 = 0;
 794   2      //                        SBUF0 = *UART_Transmit_Buffer_QueueHead;
 795   2      //                        while( !TI0 );
 796   2      //                        ++UART_Transmit_Buffer_QueueHead;
 797   2      ////              }
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 14  

 798   2      //      }
 799   2      //      else
 800   2      //        {
 801   2      //                TX_Ready = 1;                    // Indicate transmission complete
 802   2      //                TI0 = 0;                           // Clear interrupt flag
 803   2      //        }
 804   2         }
 805   1      }
 806          //-----------------------------------------------------------------------------
 807          // UART1_Interrupt
 808          //-----------------------------------------------------------------------------
 809          //
 810          // This routine is invoked whenever a character is entered or displayed on the
 811          // Hyperterminal.
 812          //
 813          //-----------------------------------------------------------------------------
 814          
 815          
 816          
 817          //-----------------------------------------------------------------------------
 818          // RerangeTheBufferQueue
 819          //-----------------------------------------------------------------------------
 820          //
 821          // This routine is invoked to rerange the UART buffer queue when the bottom point has get to the bottom li
             -mit
 822          //-----------------------------------------------------------------------------
 823          void RerangeTheBufferQueue( char IndexOfBuffer)
 824          {
 825   1              if( IndexOfBuffer == 'r')//rerange the receive buffer
 826   1              {
 827   2                      int count = UART_Receive_Buffer_QueueBottom-UART_Receive_Buffer_QueueHead;
 828   2                      int i=0;
 829   2                      for(i=0;i<count;i++)
 830   2                      {
 831   3                                      *(UART_Receive_Buffer_Queue+i)= UART_Receive_Buffer_QueueHead;
*** WARNING C260 IN LINE 831 OF FlashTestMain.c: '=': pointer truncation
 832   3                                      UART_Receive_Buffer_QueueHead++;
 833   3                                      
 834   3                      }
 835   2                      UART_Receive_Buffer_QueueHead=UART_Receive_Buffer_Queue;
 836   2                      UART_Receive_Buffer_QueueBottom=UART_Receive_Buffer_QueueHead+count;
 837   2              }
 838   1              
 839   1              if( IndexOfBuffer == 't')//rerange the transmit buffer
 840   1              {
 841   2                      int count = UART_Transmit_Buffer_QueueBottom-UART_Transmit_Buffer_QueueHead;
 842   2                      int i=0;  
 843   2                      for(i=0;i<count;i++)
 844   2                      {
 845   3                                      *(UART_Transmit_Buffer_Queue+i)= UART_Transmit_Buffer_QueueHead;
*** WARNING C260 IN LINE 845 OF FlashTestMain.c: '=': pointer truncation
 846   3                                      UART_Transmit_Buffer_QueueHead++;
 847   3                                      
 848   3                      }
 849   2                      UART_Transmit_Buffer_QueueHead=UART_Transmit_Buffer_Queue;
 850   2                      UART_Transmit_Buffer_QueueBottom=UART_Transmit_Buffer_QueueHead+count;
 851   2              }       
 852   1      }
 853          //-----------------------------------------------------------------------------
 854          // WirelessModule_Init
 855          //-----------------------------------------------------------------------------
 856          //
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 15  

 857          //-----------------------------------------------------------------------------
 858          void WirelessModule_Init(void)
 859          {
 860   1              SET=1; // Enter the SET mode of the wireless module
 861   1              memset( UART_Transmit_Buffer_Queue,0,sizeof(UART_Transmit_Buffer_Queue) );
 862   1      }
 863          //-----------------------------------------------------------------------------
 864          // Uart0_SendByte
 865          //-----------------------------------------------------------------------------
 866          //
 867          //-----------------------------------------------------------------------------
 868          void Uart0_SendByte(unsigned char value)
 869          {
 870   1              char data SFRPAGE_SAVE = SFRPAGE;//save current SFR page
 871   1              int i = 0;
 872   1              SFRPAGE = UART0_PAGE;
 873   1      //      //Check if the uart transmit is ready
 874   1      //      while(1)
 875   1      //      {
 876   1      //              if( TI0 == 0 && TX_Ready == 1)
 877   1      //              {
 878   1      //                      break;
 879   1      //              }
 880   1      //      }
 881   1      //      
 882   1      //      //Check if there are enough space
 883   1      //      if( UART_Transmit_Buffer_QueueBottom - UART_Transmit_Buffer_Queue >= UART_BUFFERSIZE )
 884   1      //      {
 885   1      //              RerangeTheBufferQueue('t');
 886   1      //      }
 887   1      //      //Write the Byte to the Transmit queue
 888   1      //      *UART_Transmit_Buffer_QueueBottom = value;
 889   1      //      ++UART_Transmit_Buffer_QueueBottom;
 890   1      //      //Set the TI0 
 891   1      //      TI0 = 1;
 892   1          while( TX_Ready == 0 );
 893   1              
 894   1              TI0 = 0;
 895   1              TX_Ready = 0;
 896   1              SBUF0 = value;
 897   1              while(!TX_Ready)
 898   1              {
 899   2                      ;
 900   2              }
 901   1              SFRPAGE = SFRPAGE_SAVE;//Recover the SFR Page
 902   1      }
 903          //-----------------------------------------------------------------------------
 904          // Calibration
 905          //-----------------------------------------------------------------------------
 906          //
 907          //-----------------------------------------------------------------------------
 908          //void Calibration(void)
 909          //{
 910          //      char a_flag = 0,w_flag = 0,angle_flag = 0;
 911          //      UART0_Receive_Buffer_Size = UART_Receive_Buffer_QueueBottom - UART_Receive_Buffer_QueueHead;
 912          ////    strcat(UART_Transmit_Buffer_QueueHead,"ReadyToAdjust");
 913          ////    UART_Transmit_Buffer_QueueBottom += strlen("ReadyToAdjust");
 914          //      Uart0_SendByte('R');
 915          //      
 916          ////    Global_SFRPAGE_SAVE = SFRPAGE;
 917          ////    SFRPAGE = ADC0_PAGE;
 918          ////    TX_Ready = 0;                  // Set the flag to zero
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 16  

 919          ////    TI0 = 1;                       // Set transmit flag to 1
 920          ////    SFRPAGE = Global_SFRPAGE_SAVE;
 921          //      
 922          //      while(1)
 923          //      {
 924          //              while( Rcv_New == 0 );//Wait for new message
 925          //              Rcv_New = 0;
 926          //              
 927          //              if( *UART_Receive_Buffer_QueueHead++ != 'Z' )
 928          //              {
 929          //                      continue;
 930          //              }
 931          //              else
 932          //              {
 933          //                      while(1)
 934          //                      {
 935          //                              if(UART1_Receive_Buffer_Queue[0]==0x55)      
 936          //                              {  
 937          //                                      switch(UART1_Receive_Buffer_Queue [1])
 938          //                                      {
 939          //                                              case 0x51:
 940          //                                              a = (int)(UART1_Receive_Buffer_Queue [3]<<8| UART1_Receive_Buffer_Queue [2]);
 941          //                                              Temp = (int)(UART1_Receive_Buffer_Queue [9]<<8| UART1_Receive_Buffer_Queue [8]);
 942          //                                              a_flag = 1;
 943          //                                              break;
 944          //                                              case 0x52:
 945          //                                              w = (int)(UART1_Receive_Buffer_Queue [3]<<8| UART1_Receive_Buffer_Queue [2]);
 946          //                                              w_flag = 1;
 947          //                                              break;
 948          //                                              case 0x53:
 949          //                                              angle = (int)((unsigned int)UART1_Receive_Buffer_Queue [3]<<8| UART1_Receive_Buffer_Queue [2]);
 950          //                                              angle_flag = 1;
 951          //                                              break;
 952          //                                      } 
 953          //                              }
 954          //                              
 955          //                              if( a_flag + w_flag + angle_flag == 3 )
 956          //                              {
 957          //                                      break;
 958          //                              }
 959          //                      }
 960          //                      
 961          //                      //Save the current state to ZeroPoint
 962          //                      ZeroPoint_a = a;
 963          //                      ZeroPoint_w = w;
 964          //                      ZeroPoint_angle = angle;
 965          //                      ZeroPoint_Temp = Temp;
 966          //                      //
 967          //                      SaveMapToFlash();
 968          //                      return;
 969          //              }
 970          
 971          //      }
 972          //}
 973          
 974          //----------------------------------------------------------------------------
 975          //----------------------------------------------------------------------------
 976          // balance_wheel
 977          //      Input:void
 978          //      Output:void
 979          //      check the whel
 980          //-----------------------------------------------------------------------------
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 17  

 981          //      Delay_ms
 982          //-----------------------------------------------------------------------------
 983          //      input:count
 984          //      output:void
 985          //      make the Program wait for count ms
 986          //-----------------------------------------------------------------------------
 987          void Delay_ms(unsigned int count)
 988          {
 989   1              unsigned char ii,jj;
 990   1              for(ii=0;ii<count;ii++)
 991   1              {
 992   2                      for(jj=0;jj<250;jj++)
 993   2                              ;
 994   2              }
 995   1      }
 996          
 997          
 998          
 999          
1000          
1001          void Uart0_TransmitString(unsigned char * pucString , int iStringSize )
1002          {
1003   1              unsigned char *pucHeadofString = pucString;
1004   1      //      if( strlen(pucString) != iStringSize )
1005   1      //      {
1006   1      //              ERROR("Uart0_TransmitString():string lenth not match");
1007   1      //      }
1008   1              
1009   1      
1010   1              while( *pucHeadofString != 0 )
1011   1              {
1012   2                      Uart0_SendByte(*pucHeadofString);
1013   2                      ++pucHeadofString;
1014   2              }
1015   1              
1016   1              
1017   1      }
*** WARNING C280 IN LINE 1001 OF FlashTestMain.c: 'iStringSize': unreferenced local variable
1018          
1019          void PWMChange(unsigned int side_ui, unsigned int PWM_degree)
1020          {
1021   1              char data SFRPAGE_SAVE =SFRPAGE;
1022   1              SFRPAGE=0x0f;
1023   1              /*************************DEBUG BEGIN*************************/
1024   1              if( PWM_degree > 256 )
1025   1              {
1026   2                      ERROR("function PWMChange():PWM_degree is too large");
1027   2              }
1028   1      //      PWM_debug1 = (unsigned char)uiPWM1Degree;
1029   1      //      PWM_debug2 = (unsigned char)uiPWM2Degree << 4;
1030   1      //      PWM_debug3  = (unsigned char)uiPWM1Degree + (unsigned char)uiPWM2Degree << 4;
1031   1      //      PWM_debug4 = PWM_debug1 + PWM_debug2;
1032   1              //------------------------DEBUG END-------------------------------
1033   1              
1034   1              P5 = PWM_degree;
1035   1              if(side_ui == 2)
1036   1              {
1037   2                      PWM1CHANGEORDER =  0;
1038   2                      Delay_ms(4);
1039   2                      while( PWM1CHANGEORDER != 0 );//wait
1040   2                      PWM1CHANGEORDER =  1;
1041   2              }
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 18  

1042   1              else if(side_ui == 1)
1043   1              {
1044   2                      PWM2CHANGEORDER =  0;
1045   2                      Delay_ms(4);
1046   2                      while( PWM2CHANGEORDER != 0 );//wait
1047   2                      PWM2CHANGEORDER =  1;
1048   2              }
1049   1              SFRPAGE = SFRPAGE_SAVE;
1050   1      }
1051          void TouchKeepAlive(void)
1052          {
1053   1              char data SFRPAGE_SAVE =SFRPAGE;
1054   1              SFRPAGE=TIMER01_PAGE;
1055   1              KeepAliveTime_i = 0;
1056   1              ET0 = 1;//Enable Timer0 interrupt
1057   1              TR0 = 1;//Run Timer0
1058   1              SFRPAGE = SFRPAGE_SAVE;
1059   1      }
1060          void LostConnect(void)
1061          {
1062   1              uiPWM1Degree=uiPWM2Degree=0;
1063   1              PWMChange(1, 0);        
1064   1              PWMChange(2, 0);
1065   1              IN11=0;
1066   1              IN12=0;
1067   1              IN31=0;
1068   1              IN32=0;
1069   1      //      Uart0_TransmitString("lost connect",strlen("lost connect"));
1070   1      //      Acknowledge('s');
1071   1      }
1072          void Acknowledge(unsigned char back)
1073          {
1074   1              Uart0_SendByte(0x53);
1075   1              Uart0_SendByte(back);
1076   1              Uart0_SendByte(1);
1077   1              Uart0_SendByte(back+1);
1078   1              
1079   1              
1080   1      }
1081          void Acknowledge_54(unsigned char index, unsigned char flag, unsigned char error)
1082          {
1083   1              Uart0_SendByte(0x54);
1084   1              Uart0_SendByte(index);
1085   1              Uart0_SendByte(flag);
1086   1              Uart0_SendByte(error);
1087   1              Uart0_SendByte(0x54+flag+error);
1088   1      }
1089          void Report_PWM_55(void)
1090          {
1091   1              Uart0_SendByte(0x55);
1092   1              Uart0_SendByte(PWM_L_ui);
1093   1              Uart0_SendByte(PWM_R_ui);
1094   1      }
1095          //void balance_wheel(void)
1096          //{
1097          //      static l_up_flag = 0;
1098          //      static r_up_flag = 0;
1099          //      if(L_UP && ~l_up_flag)//increase left pwm
1100          //      {
1101          //              PWM_L_ui += 1;
1102          //              PWMChange(1, PWM_L_ui);
1103          //      }
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 19  

1104          //      else
1105          //      {
1106          //              l_up_flag=0;
1107          //      }
1108          ////    else if(L_DOWN)// decrease left pwm
1109          ////    {
1110          ////            PWM_L_ui -= 1;
1111          ////            PWMChange(1, PWM_L_ui);
1112          ////    }
1113          //      
1114          //      if(R_UP && ~r_up_flag)//increase right pwm
1115          //      {
1116          //              PWM_R_ui += 1;
1117          //              PWMChange(2, PWM_R_ui);
1118          //      }
1119          //      else
1120          //      {
1121          //              r_up_flag=0;
1122          //      }
1123          ////    else if(R_DOWN)//decrease right pwm
1124          ////    {
1125          ////            PWM_R_ui -= 1;
1126          ////            PWMChange(2, PWM_R_ui);
1127          ////    }
1128          //}
1129          
1130          void Check_Counter(unsigned int *Counter_L_p, unsigned int *Counter_R_p, unsigned long *Counter_HighBits_a
             -)
1131          {
1132   1      #ifndef CHECK_COUNTER_DEBUG
1133   1              static unsigned int c_L = 0;
1134   1              static unsigned int c_R = 0;
1135   1                                              char debug = 0;
1136   1      #endif
1137   1              char SFRPAGE_SAVE = SFRPAGE;        // Save Current SFR page
1138   1              SFRPAGE = TMR4_PAGE;                // Set SFR page
1139   1              *Counter_R_p = TMR4H;
1140   1              *Counter_R_p = *Counter_R_p << 8;
1141   1              *Counter_R_p += TMR4L;
1142   1              SFRPAGE = TMR3_PAGE;                // Set SFR page
1143   1              *Counter_L_p = TMR3H;
1144   1              *Counter_L_p = *Counter_L_p << 8;
1145   1              *Counter_L_p += TMR3L;
1146   1              
1147   1              if(*Counter_L_p >= 50000)
1148   1              {
1149   2                      TMR3H = 0;
1150   2                      TMR3L = 0;
1151   2                      *Counter_L_p = 0;
1152   2                      ++*(Counter_HighBits_a);
1153   2              }
1154   1              if(*Counter_R_p >= 50000)
1155   1              {
1156   2                      SFRPAGE = TMR4_PAGE;                // Set SFR page
1157   2                      TMR4H = 0;
1158   2                      TMR4L = 0;
1159   2                      *Counter_R_p = 0;
1160   2                      ++*(Counter_HighBits_a+1);
1161   2              }
1162   1              
1163   1      #ifndef CHECK_COUNTER_DEBUG
1164   1              if(*Counter_L_p > c_L )
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 20  

1165   1              {
1166   2                      c_L = *Counter_L_p;
1167   2              }
1168   1              if(*Counter_R_p > c_R )
1169   1              {
1170   2                      c_R = *Counter_R_p;
1171   2              }
1172   1              if(*Counter_R_p > 2000)
1173   1              {
1174   2                      c_R = *Counter_R_p;
1175   2              }
1176   1      //      if( TMR3_1000_circles > 0 )
1177   1      //      {
1178   1      //              debug ++; 
1179   1      //      }
1180   1      #endif
1181   1              SFRPAGE = SFRPAGE_SAVE;
1182   1      }
1183          void process_msg_53(void)
1184          {
1185   1              char WaitFailSign = 0;
1186   1              ++UART_Receive_Buffer_QueueHead;
1187   1              while( UART_Receive_Buffer_QueueBottom - UART_Receive_Buffer_QueueHead < 3 )
1188   1              {
1189   2                      //wait the rest three char
1190   2                      if(KeepAliveTime_i > 100)
1191   2                      {
1192   3                              //wait too long 
1193   3                              WaitFailSign = 1;
1194   3                              UART_Receive_Buffer_QueueHead = UART_Receive_Buffer_QueueBottom;
1195   3                              return;
1196   3                      }
1197   2              }
1198   1      
1199   1              //check the sum 
1200   1              if( *UART_Receive_Buffer_QueueHead + *(UART_Receive_Buffer_QueueHead+1) != *(UART_Receive_Buffer_QueueHea
             -d+2) )
1201   1              {
1202   2                      /*debug*/
1203   2                      Uart0_SendByte('w');
1204   2                      UART_Receive_Buffer_QueueHead+=3;
1205   2                      /*debug end*/
1206   2                      return;
1207   2              }
1208   1              //next char (order) come
1209   1              car_state = *UART_Receive_Buffer_QueueHead;
1210   1              switch(*UART_Receive_Buffer_QueueHead)
1211   1              {
1212   2      //                                      case 'g'://start the car
1213   2      //                                              uiPWM1Degree=uiPWM2Degree=*(UART_Receive_Buffer_QueueHead+1);
1214   2      //                                              PWMChange();
1215   2      //                                              IN11=1;
1216   2      //                                              IN12=0;
1217   2      //                                              IN31=1;
1218   2      //                                              IN32=0;
1219   2      //                                              TouchKeepAlive();
1220   2      //                                              Acknowledge(*UART_Receive_Buffer_QueueHead);
1221   2      //                                              break;
1222   2                      case 'f'://forward
1223   2                              uiPWM1Degree=uiPWM2Degree=*(UART_Receive_Buffer_QueueHead+1);
1224   2      //                                              PWMChange();                                            
1225   2      //                                              IN11=1;
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 21  

1226   2      //                                              IN12=0;
1227   2      //                                              IN31=1;
1228   2      //                                              IN32=0;
1229   2                              if(uiPWM1Degree > 4)
1230   2                              {
1231   3                                      uiPWM1Degree = 4;
1232   3                              }
1233   2                              TouchKeepAlive();
1234   2                              Acknowledge(*UART_Receive_Buffer_QueueHead);
1235   2                              break;
1236   2                      case 'l'://turn left
1237   2                              uiPWM1Degree=uiPWM2Degree=*(UART_Receive_Buffer_QueueHead+1);
1238   2                              PWMChange(1, uiPWM1Degree * 64 -1);     
1239   2                              PWMChange(2, uiPWM2Degree * 64 -1);     
1240   2                              IN11=0;
1241   2                              IN12=0;
1242   2                              IN31=1;
1243   2                              IN32=0;
1244   2                              TouchKeepAlive();
1245   2                              Acknowledge(*UART_Receive_Buffer_QueueHead);
1246   2                              break;
1247   2                      case 'r'://turn right
1248   2                              uiPWM1Degree=uiPWM2Degree=*(UART_Receive_Buffer_QueueHead+1);
1249   2                              PWMChange(1, uiPWM1Degree * 64 -1);     
1250   2                              PWMChange(2, uiPWM2Degree * 64 -1);                                             
1251   2                              IN11=1;
1252   2                              IN12=0;
1253   2                              IN31=0;
1254   2                              IN32=0;
1255   2                              TouchKeepAlive();
1256   2                              Acknowledge(*UART_Receive_Buffer_QueueHead);
1257   2                              break;
1258   2                      case 'b'://go back
1259   2                              uiPWM1Degree=uiPWM2Degree=*(UART_Receive_Buffer_QueueHead+1);
1260   2                              PWMChange(1, uiPWM1Degree * 64 -1);     
1261   2                              PWMChange(2, uiPWM2Degree * 64 -1);
1262   2                              IN11=0;
1263   2                              IN12=1;
1264   2                              IN31=0;
1265   2                              IN32=1;
1266   2                              TouchKeepAlive();
1267   2                              Acknowledge(*UART_Receive_Buffer_QueueHead);
1268   2                              break;
1269   2                      case 's'://stop
1270   2                              uiPWM1Degree=uiPWM2Degree=0;
1271   2                              PWMChange(1, 0);        
1272   2                              PWMChange(2, 0);
1273   2                              IN11=0;
1274   2                              IN12=0;
1275   2                              IN31=0;
1276   2                              IN32=0;
1277   2                              TouchKeepAlive();
1278   2                              Acknowledge(*UART_Receive_Buffer_QueueHead);
1279   2                              break;
1280   2                      default:
1281   2                              /*debug*/
1282   2                              Acknowledge('n');//No such order
1283   2                              /*debug end*/
1284   2                              break;                                          
1285   2              }
1286   1              UART_Receive_Buffer_QueueHead+=3;
1287   1      
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 22  

1288   1      }
1289          void process_msg_54(void)
1290          {
1291   1      
1292   1              char WaitFailSign = 0;
1293   1              unsigned char Msg_a[7] = {0};
1294   1              int i = 0;
1295   1              unsigned int sum= 0x54;
1296   1                      
1297   1              ++UART_Receive_Buffer_QueueHead;// throw header 0x54
1298   1              //Wait for the whole message
1299   1              while( UART_Receive_Buffer_QueueBottom - UART_Receive_Buffer_QueueHead < 6 )
1300   1              {
1301   2                      //wait the rest three char
1302   2                      if(KeepAliveTime_i > 100)
1303   2                      {
1304   3                              //wait too long 
1305   3                              WaitFailSign = 1;
1306   3                              UART_Receive_Buffer_QueueHead = UART_Receive_Buffer_QueueBottom;
1307   3                              return;
1308   3                      }
1309   2              }
1310   1              
1311   1              // Take the msg out from the buffer
1312   1              memcpy(Msg_a, UART_Receive_Buffer_QueueHead, 6);
1313   1              UART_Receive_Buffer_QueueHead += 6; // clear this fragment from buffer
1314   1              // Check the sum
1315   1              for(i=0;i++;i<5)
1316   1              {
1317   2                      sum += Msg_a[i];
1318   2              }
1319   1              if( sum & 0x00ff != Msg_a[5])
1320   1              {
1321   2                      // cracked msg
1322   2                      Acknowledge_54(Msg_a[0], 1, 1);
1323   2                      return;
1324   2              }
1325   1              // Change the PWM and rotation. 
1326   1              PWMChange(1, Msg_a[1]);
1327   1              PWMChange(2, Msg_a[2]);
1328   1              switch(Msg_a[3])  //left rotation
1329   1              {
1330   2                      case 0://stop
1331   2                              IN11=0;
1332   2                              IN12=0;
1333   2                              break;
1334   2                      case 1://forward
1335   2                              IN11=1;
1336   2                              IN12=0;
1337   2                              break;
1338   2                      case 2://backward
1339   2                              IN11=0;
1340   2                              IN12=1;
1341   2                              break;
1342   2                      default:// error
1343   2                              Acknowledge_54(Msg_a[0], 1, 2);
1344   2              }
1345   1              switch(Msg_a[4]) //right wheel rotation
1346   1              {
1347   2                      case 0://stop
1348   2                              IN31=0;
1349   2                              IN32=0;
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 23  

1350   2                              break;
1351   2                      case 1://forward
1352   2                              IN31=1;
1353   2                              IN32=0;
1354   2                              break;
1355   2                      case 2://backward
1356   2                              IN31 = 0;
1357   2                              IN32 = 1;
1358   2                              break;
1359   2                      default:// error
1360   2                              Acknowledge_54(Msg_a[0], 1, 2);
1361   2              }
1362   1              TouchKeepAlive();
1363   1              return;
1364   1      }
1365          /*0x55+order+pwm+sum*/
1366          void process_msg_55(void)
1367          {
1368   1              char WaitFailSign = 0;
1369   1              unsigned char Msg_a[7] = {0};
1370   1              unsigned char sum= 0;
1371   1              ++UART_Receive_Buffer_QueueHead;// throw header 0x55
1372   1              //Wait for the whole message
1373   1              while( UART_Receive_Buffer_QueueBottom - UART_Receive_Buffer_QueueHead < 3 )
1374   1              {
1375   2                      //wait the rest three char
1376   2                      if(KeepAliveTime_i > 100)
1377   2                      {
1378   3                              //wait too long 
1379   3                              WaitFailSign = 1;
1380   3                              UART_Receive_Buffer_QueueHead = UART_Receive_Buffer_QueueBottom;
1381   3                              return;
1382   3                      }
1383   2              }
1384   1              
1385   1              // Take the msg out from the buffer
1386   1              memcpy(Msg_a, UART_Receive_Buffer_QueueHead, 3);
1387   1              UART_Receive_Buffer_QueueHead += 3; // clear this fragment from buffer
1388   1              // Check the sum
1389   1              sum += Msg_a[0];
1390   1              sum += Msg_a[1];
1391   1              if( sum & 0xff - Msg_a[2])
1392   1              {
1393   2                      // cracked msg
1394   2                      return;
1395   2              }
1396   1              switch(Msg_a[0])
1397   1              {
1398   2                      case 1://start forwarding
1399   2                              IN11=1;
1400   2                              IN12=0;
1401   2                              IN31=1;
1402   2                              IN32=0;
1403   2                              PWM_L_ui = Msg_a[1] *48;
1404   2                              PWM_R_ui = PWM_L_ui;
1405   2                              PWMChange(1, PWM_L_ui);
1406   2                              PWMChange(2, PWM_R_ui);
1407   2                              global_balance_flag = 1;
1408   2                              START_BALANCe = 1;
1409   2                              break;
1410   2                      case 4://keep going
1411   2                              break;
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 24  

1412   2                      case 2://start going back
1413   2                              IN11=0;
1414   2                              IN12=1;
1415   2                              IN31=0;
1416   2                              IN32=1;
1417   2                              PWM_L_ui = Msg_a[1] *48;
1418   2                              PWM_R_ui = PWM_L_ui;
1419   2                              PWMChange(1, PWM_L_ui);
1420   2                              PWMChange(2, PWM_R_ui);
1421   2                              break;
1422   2                      case 3://stop
1423   2                              IN11=1;
1424   2                              IN12=1;
1425   2                              IN31=1;
1426   2                              IN32=1;
1427   2                              global_balance_flag = 0;
1428   2                              START_BALANCe = 0;
1429   2                              PWM_R_add = 0;
1430   2                              PWM_L_add = 0;
1431   2                              break;
1432   2                      default:
1433   2                              break;
1434   2                              
1435   2              }
1436   1              TouchKeepAlive();
1437   1      }
1438          void INT0_ISR (void) interrupt 0
1439          {
1440   1              if(global_balance_flag)
1441   1              {
1442   2                      if(PWM_L_ui == 48)
1443   2                      {
1444   3                              PWM_L_ui += 8;
1445   3                              PWMChange(1, PWM_L_ui);
1446   3                              Report_PWM_55();
1447   3                      }
1448   2                      else
1449   2                      {
1450   3                              
1451   3                              PWM_R_ui = 48;
1452   3                              PWMChange(2, PWM_R_ui);
1453   3                              Report_PWM_55();
1454   3                      }
1455   2              }
1456   1      }
1457          
1458          //-----------------------------------------------------------------------------
1459          // /INT1 ISR
1460          //-----------------------------------------------------------------------------
1461          //
1462          // Whenever a negative edge appears on P0.1, the LED is toggled.
1463          // The interrupt pending flag is automatically cleared by vectoring to the ISR
1464          //
1465          //-----------------------------------------------------------------------------
1466          void INT1_ISR (void) interrupt 2
1467          {
1468   1              if(global_balance_flag)
1469   1              {
1470   2                      if(PWM_R_ui == 48)
1471   2                      {
1472   3                              PWM_R_ui += 8;
1473   3                              PWMChange(2, PWM_R_ui);
C51 COMPILER V9.53.0.0   FLASHTESTMAIN                                                     12/12/2015 12:42:56 PAGE 25  

1474   3                              Report_PWM_55();
1475   3                      }
1476   2                      else
1477   2                      {
1478   3                              PWM_L_ui = 48;
1479   3                              PWMChange(1, PWM_L_ui);
1480   3                              Report_PWM_55();
1481   3                      }
1482   2              }
1483   1      }
1484          void Ext_Interrupt_Init (void)
1485          {
1486   1         char SFRPAGE_SAVE = SFRPAGE;
1487   1      
1488   1         SFRPAGE = TIMER01_PAGE;
1489   1      
1490   1         TCON |= 0x05;                        // /INT 0 and /INT 1 are falling edge
1491   1                                             // triggered
1492   1      
1493   1         EX0 = 1;                            // Enable /INT0 interrupts
1494   1         EX1 = 1;                            // Enable /INT1 interrupts
1495   1      
1496   1         SFRPAGE = SFRPAGE_SAVE;
1497   1      }
1498          //-----------------------------------------------------------------------------
1499          // End Of File
1500          //-----------------------------------------------------------------------------
*** WARNING C294 IN LINE 399 OF FlashTestMain.c: unreachable code
*** WARNING C294 IN LINE 405 OF FlashTestMain.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3442    ----
   CONSTANT SIZE    =     73    ----
   XDATA SIZE       =    317      64
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  5 WARNING(S),  0 ERROR(S)
